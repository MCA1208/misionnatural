"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/activities/page",{

/***/ "(app-pages-browser)/./app/dashboard/activities/page.js":
/*!******************************************!*\
  !*** ./app/dashboard/activities/page.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mui_material_Container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mui/material/Container */ \"(app-pages-browser)/./node_modules/@mui/material/Container/Container.js\");\n/* harmony import */ var react_i18next__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-i18next */ \"(app-pages-browser)/./node_modules/react-i18next/dist/es/index.js\");\n/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! i18next */ \"(app-pages-browser)/./node_modules/i18next/dist/esm/i18next.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\nfunction page() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_i18next__WEBPACK_IMPORTED_MODULE_2__.I18nextProvider, {\n            i18n: i18next__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material_Container__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                maxWidth: \"lg\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppBar, {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\milto\\\\Desktop\\\\Repositorio\\\\mision\\\\app\\\\dashboard\\\\activities\\\\page.js\",\n                        lineNumber: 12,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        children: \"Page not available\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\milto\\\\Desktop\\\\Repositorio\\\\mision\\\\app\\\\dashboard\\\\activities\\\\page.js\",\n                        lineNumber: 13,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Footer, {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\milto\\\\Desktop\\\\Repositorio\\\\mision\\\\app\\\\dashboard\\\\activities\\\\page.js\",\n                        lineNumber: 15,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\milto\\\\Desktop\\\\Repositorio\\\\mision\\\\app\\\\dashboard\\\\activities\\\\page.js\",\n                lineNumber: 11,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\milto\\\\Desktop\\\\Repositorio\\\\mision\\\\app\\\\dashboard\\\\activities\\\\page.js\",\n            lineNumber: 10,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\milto\\\\Desktop\\\\Repositorio\\\\mision\\\\app\\\\dashboard\\\\activities\\\\page.js\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (page);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9kYXNoYm9hcmQvYWN0aXZpdGllcy9wYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQzBCO0FBQ3NCO0FBQ2dCO0FBQ2xDO0FBRTlCLFNBQVNLO0lBQ1AscUJBQ0UsOERBQUNDO2tCQUNDLDRFQUFDSiwwREFBZUE7WUFBQ0ssTUFBTUgsK0NBQU9BO3NCQUM1Qiw0RUFBQ0gsK0RBQVNBO2dCQUFDTyxVQUFTOztrQ0FDbEIsOERBQUNDOzs7OztrQ0FDRCw4REFBQ0M7a0NBQUc7Ozs7OztrQ0FFSiw4REFBQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtYO0FBRUEsK0RBQWVOLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2Rhc2hib2FyZC9hY3Rpdml0aWVzL3BhZ2UuanM/NDIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gXCJAbXVpL21hdGVyaWFsL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBJMThuZXh0UHJvdmlkZXIsIHVzZVRyYW5zbGF0aW9uIH0gZnJvbSBcInJlYWN0LWkxOG5leHRcIjtcclxuaW1wb3J0IGkxOG5leHQgZnJvbSBcImkxOG5leHRcIjtcclxuXHJcbmZ1bmN0aW9uIHBhZ2UoKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcbiAgICAgIDxJMThuZXh0UHJvdmlkZXIgaTE4bj17aTE4bmV4dH0+XHJcbiAgICAgICAgPENvbnRhaW5lciBtYXhXaWR0aD1cImxnXCI+XHJcbiAgICAgICAgICA8QXBwQmFyIC8+XHJcbiAgICAgICAgICA8aDM+UGFnZSBub3QgYXZhaWxhYmxlPC9oMz5cclxuXHJcbiAgICAgICAgICA8Rm9vdGVyIC8+XHJcbiAgICAgICAgPC9Db250YWluZXI+XHJcbiAgICAgIDwvSTE4bmV4dFByb3ZpZGVyPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGFnZTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ29udGFpbmVyIiwiSTE4bmV4dFByb3ZpZGVyIiwidXNlVHJhbnNsYXRpb24iLCJpMThuZXh0IiwicGFnZSIsImRpdiIsImkxOG4iLCJtYXhXaWR0aCIsIkFwcEJhciIsImgzIiwiRm9vdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/dashboard/activities/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: function() { return /* binding */ changeLanguage; },\n/* harmony export */   createInstance: function() { return /* binding */ createInstance; },\n/* harmony export */   \"default\": function() { return /* binding */ instance; },\n/* harmony export */   dir: function() { return /* binding */ dir; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   getFixedT: function() { return /* binding */ getFixedT; },\n/* harmony export */   hasLoadedNamespace: function() { return /* binding */ hasLoadedNamespace; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   loadLanguages: function() { return /* binding */ loadLanguages; },\n/* harmony export */   loadNamespaces: function() { return /* binding */ loadNamespaces; },\n/* harmony export */   loadResources: function() { return /* binding */ loadResources; },\n/* harmony export */   reloadResources: function() { return /* binding */ reloadResources; },\n/* harmony export */   setDefaultNamespace: function() { return /* binding */ setDefaultNamespace; },\n/* harmony export */   t: function() { return /* binding */ t; },\n/* harmony export */   use: function() { return /* binding */ use; }\n/* harmony export */ });\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        if (console && console[type]) console[type].apply(console, args);\n    }\n};\nclass Logger {\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (typeof args[0] === \"string\") args[0] = \"\".concat(prefix).concat(this.prefix, \" \").concat(args[0]);\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: \"\".concat(this.prefix, \":\").concat(moduleName, \":\")\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            if (!this.observers[event]) this.observers[event] = new Map();\n            const numListeners = this.observers[event].get(listener) || 0;\n            this.observers[event].set(listener, numListeners + 1);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event].delete(listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = Array.from(this.observers[event].entries());\n            cloned.forEach((_ref)=>{\n                let [observer, numTimesAdded] = _ref;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer(...args);\n                }\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = Array.from(this.observers[\"*\"].entries());\n            cloned.forEach((_ref2)=>{\n                let [observer, numTimesAdded] = _ref2;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                }\n            });\n        }\n    }\n    constructor(){\n        this.observers = {};\n    }\n}\nconst defer = ()=>{\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n};\nconst makeString = (object)=>{\n    if (object == null) return \"\";\n    return \"\" + object;\n};\nconst copy = (a, s, t)=>{\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = (key)=>key && key.indexOf(\"###\") > -1 ? key.replace(lastOfPathSeparatorRegExp, \".\") : key;\nconst canNotTraverseDeeper = (object)=>!object || typeof object === \"string\";\nconst getLastOfPath = (object, path, Empty)=>{\n    const stack = typeof path !== \"string\" ? path : path.split(\".\");\n    let stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper(object)) return {};\n        const key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper(object)) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n};\nconst setPath = (object, path, newValue)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    let e = path[path.length - 1];\n    let p = path.slice(0, path.length - 1);\n    let last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = \"\".concat(p[p.length - 1], \".\").concat(e);\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if (last && last.obj && typeof last.obj[\"\".concat(last.k, \".\").concat(e)] !== \"undefined\") {\n            last.obj = undefined;\n        }\n    }\n    last.obj[\"\".concat(last.k, \".\").concat(e)] = newValue;\n};\nconst pushPath = (object, path, newValue, concat)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n};\nconst getPath = (object, path)=>{\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key)=>{\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite)=>{\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (typeof target[prop] === \"string\" || target[prop] instanceof String || typeof source[prop] === \"string\" || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\nconst regexEscape = (str)=>str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nconst escape = (data)=>{\n    if (typeof data === \"string\") {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n};\nclass RegExpCache {\n    getRegExp(pattern) {\n        const regExpFromCache = this.regExpMap.get(pattern);\n        if (regExpFromCache !== undefined) {\n            return regExpFromCache;\n        }\n        const regExpNew = new RegExp(pattern);\n        if (this.regExpQueue.length === this.capacity) {\n            this.regExpMap.delete(this.regExpQueue.shift());\n        }\n        this.regExpMap.set(pattern, regExpNew);\n        this.regExpQueue.push(pattern);\n        return regExpNew;\n    }\n    constructor(capacity){\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator)=>{\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = looksLikeObjectPathRegExpCache.getRegExp(\"(\".concat(possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\"), \")\"));\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n};\nconst deepFind = function(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) return obj[path];\n    const tokens = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < tokens.length;){\n        if (!current || typeof current !== \"object\") {\n            return undefined;\n        }\n        let next;\n        let nextPath = \"\";\n        for(let j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    \"string\",\n                    \"number\",\n                    \"boolean\"\n                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n};\nconst getCleanedCode = (code)=>{\n    if (code && code.indexOf(\"_\") > 0) return code.replace(\"_\", \"-\");\n    return code;\n};\nclass ResourceStore extends EventEmitter {\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path;\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        } else {\n            path = [\n                lng,\n                ns\n            ];\n            if (key) {\n                if (Array.isArray(key)) {\n                    path.push(...key);\n                } else if (typeof key === \"string\" && keySeparator) {\n                    path.push(...key.split(keySeparator));\n                } else {\n                    path.push(key);\n                }\n            }\n        }\n        const result = getPath(this.data, path);\n        if (!result && !ns && !key && lng.indexOf(\".\") > -1) {\n            lng = path[0];\n            ns = path[1];\n            key = path.slice(2).join(\".\");\n        }\n        if (result || !ignoreJSONStructure || typeof key !== \"string\") return result;\n        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (typeof resources[m] === \"string\" || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false,\n            skipCopy: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        if (this.options.compatibilityAPI === \"v1\") return {\n            ...{},\n            ...this.getResource(lng, ns)\n        };\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key === undefined || key === null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved && resolved.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        return {\n            key,\n            namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys === undefined || keys === null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng && lng.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: \"\".concat(namespace).concat(nsSeparator).concat(key),\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return \"\".concat(namespace).concat(nsSeparator).concat(key);\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved && resolved.res;\n        const resUsedKey = resolved && resolved.usedKey || key;\n        const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n        const resType = Object.prototype.toString.apply(res);\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const handleAsObject = typeof res !== \"string\" && typeof res !== \"boolean\" && typeof res !== \"number\";\n        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === \"string\" && Array.isArray(res))) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n                    ...options,\n                    ns: namespaces\n                }) : \"key '\".concat(key, \" (\").concat(this.language, \")' returned an object instead of string.\");\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = Array.isArray(res);\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in res){\n                    if (Object.prototype.hasOwnProperty.call(res, m)) {\n                        const deepKey = \"\".concat(newKeyToUse).concat(keySeparator).concat(m);\n                        copy[m] = this.translate(deepKey, {\n                            ...options,\n                            ...{\n                                joinArrays: false,\n                                ns: namespaces\n                            }\n                        });\n                        if (copy[m] === deepKey) copy[m] = res[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && typeof joinArrays === \"string\" && Array.isArray(res)) {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const hasDefaultValue = Translator.hasDefaultValue(options);\n            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n            const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n                ordinal: false\n            }) : \"\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const defaultValue = needsZeroSuffixLookup && options[\"defaultValue\".concat(this.options.pluralSeparator, \"zero\")] || options[\"defaultValue\".concat(defaultValueSuffix)] || options[\"defaultValue\".concat(defaultValueSuffixOrdinalFallback)] || options.defaultValue;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            const suffixes = this.pluralResolver.getSuffixes(language, options);\n                            if (needsZeroSuffixLookup && options[\"defaultValue\".concat(this.options.pluralSeparator, \"zero\")] && suffixes.indexOf(\"\".concat(this.options.pluralSeparator, \"zero\")) < 0) {\n                                suffixes.push(\"\".concat(this.options.pluralSeparator, \"zero\"));\n                            }\n                            suffixes.forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[\"defaultValue\".concat(suffix)] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = \"\".concat(namespace, \":\").concat(key);\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                if (this.options.compatibilityAPI !== \"v1\") {\n                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? \"\".concat(namespace, \":\").concat(key) : key, usedDefault ? res : undefined);\n                } else {\n                    res = this.options.parseMissingKeyHandler(res);\n                }\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat && this.i18nFormat.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = typeof res === \"string\" && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && typeof options.replace !== \"string\" ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && this.options.compatibilityAPI !== \"v1\" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey && lastKey[0] === args[0] && !options.context) {\n                    _this.logger.warn(\"It seems you are nesting recursively key: \".concat(args[0], \" in key: \").concat(key[0]));\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = typeof postProcess === \"string\" ? [\n            postProcess\n        ] : postProcess;\n        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (typeof keys === \"string\") keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const needsContextHandling = options.context !== undefined && (typeof options.context === \"string\" || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[\"\".concat(codes[0], \"-\").concat(ns)] = true;\n                    this.logger.warn('key \"'.concat(usedKey, '\" for languages \"').concat(codes.join(\", \"), '\" won\\'t get resolved as namespace \"').concat(usedNS, '\" was not yet loaded'), \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = \"\".concat(this.options.pluralSeparator, \"zero\");\n                        const ordinalPrefix = \"\".concat(this.options.pluralSeparator, \"ordinal\").concat(this.options.pluralSeparator);\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = \"\".concat(key).concat(this.options.contextSeparator).concat(options.context);\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && typeof options.replace !== \"string\";\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n}\nconst capitalize = (string)=>string.charAt(0).toUpperCase() + string.slice(1);\nclass LanguageUtil {\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (typeof code === \"string\" && code.indexOf(\"-\") > -1) {\n            const specialCases = [\n                \"hans\",\n                \"hant\",\n                \"latn\",\n                \"cyrl\",\n                \"cans\",\n                \"mong\",\n                \"arab\"\n            ];\n            let p = code.split(\"-\");\n            if (this.options.lowerCaseLng) {\n                p = p.map((part)=>part.toLowerCase());\n            } else if (p.length === 2) {\n                p[0] = p[0].toLowerCase();\n                p[1] = p[1].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n            } else if (p.length === 3) {\n                p[0] = p[0].toLowerCase();\n                if (p[1].length === 2) p[1] = p[1].toUpperCase();\n                if (p[0] !== \"sgn\" && p[2].length === 2) p[2] = p[2].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n            }\n            return p.join(\"-\");\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(\"-\") > 0 && lngOnly.indexOf(\"-\") < 0 && supportedLng.substring(0, supportedLng.indexOf(\"-\")) === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (typeof fallbacks === \"string\") fallbacks = [\n            fallbacks\n        ];\n        if (Array.isArray(fallbacks)) return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(\"rejecting language code not found in supportedLngs: \".concat(c));\n            }\n        };\n        if (typeof code === \"string\" && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (typeof code === \"string\") {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n}\nlet sets = [\n    {\n        lngs: [\n            \"ach\",\n            \"ak\",\n            \"am\",\n            \"arn\",\n            \"br\",\n            \"fil\",\n            \"gun\",\n            \"ln\",\n            \"mfe\",\n            \"mg\",\n            \"mi\",\n            \"oc\",\n            \"pt\",\n            \"pt-BR\",\n            \"tg\",\n            \"tl\",\n            \"ti\",\n            \"tr\",\n            \"uz\",\n            \"wa\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 1\n    },\n    {\n        lngs: [\n            \"af\",\n            \"an\",\n            \"ast\",\n            \"az\",\n            \"bg\",\n            \"bn\",\n            \"ca\",\n            \"da\",\n            \"de\",\n            \"dev\",\n            \"el\",\n            \"en\",\n            \"eo\",\n            \"es\",\n            \"et\",\n            \"eu\",\n            \"fi\",\n            \"fo\",\n            \"fur\",\n            \"fy\",\n            \"gl\",\n            \"gu\",\n            \"ha\",\n            \"hi\",\n            \"hu\",\n            \"hy\",\n            \"ia\",\n            \"it\",\n            \"kk\",\n            \"kn\",\n            \"ku\",\n            \"lb\",\n            \"mai\",\n            \"ml\",\n            \"mn\",\n            \"mr\",\n            \"nah\",\n            \"nap\",\n            \"nb\",\n            \"ne\",\n            \"nl\",\n            \"nn\",\n            \"no\",\n            \"nso\",\n            \"pa\",\n            \"pap\",\n            \"pms\",\n            \"ps\",\n            \"pt-PT\",\n            \"rm\",\n            \"sco\",\n            \"se\",\n            \"si\",\n            \"so\",\n            \"son\",\n            \"sq\",\n            \"sv\",\n            \"sw\",\n            \"ta\",\n            \"te\",\n            \"tk\",\n            \"ur\",\n            \"yo\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ay\",\n            \"bo\",\n            \"cgg\",\n            \"fa\",\n            \"ht\",\n            \"id\",\n            \"ja\",\n            \"jbo\",\n            \"ka\",\n            \"km\",\n            \"ko\",\n            \"ky\",\n            \"lo\",\n            \"ms\",\n            \"sah\",\n            \"su\",\n            \"th\",\n            \"tt\",\n            \"ug\",\n            \"vi\",\n            \"wo\",\n            \"zh\"\n        ],\n        nr: [\n            1\n        ],\n        fc: 3\n    },\n    {\n        lngs: [\n            \"be\",\n            \"bs\",\n            \"cnr\",\n            \"dz\",\n            \"hr\",\n            \"ru\",\n            \"sr\",\n            \"uk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 4\n    },\n    {\n        lngs: [\n            \"ar\"\n        ],\n        nr: [\n            0,\n            1,\n            2,\n            3,\n            11,\n            100\n        ],\n        fc: 5\n    },\n    {\n        lngs: [\n            \"cs\",\n            \"sk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 6\n    },\n    {\n        lngs: [\n            \"csb\",\n            \"pl\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 7\n    },\n    {\n        lngs: [\n            \"cy\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            8\n        ],\n        fc: 8\n    },\n    {\n        lngs: [\n            \"fr\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 9\n    },\n    {\n        lngs: [\n            \"ga\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            7,\n            11\n        ],\n        fc: 10\n    },\n    {\n        lngs: [\n            \"gd\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            20\n        ],\n        fc: 11\n    },\n    {\n        lngs: [\n            \"is\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 12\n    },\n    {\n        lngs: [\n            \"jv\"\n        ],\n        nr: [\n            0,\n            1\n        ],\n        fc: 13\n    },\n    {\n        lngs: [\n            \"kw\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            4\n        ],\n        fc: 14\n    },\n    {\n        lngs: [\n            \"lt\"\n        ],\n        nr: [\n            1,\n            2,\n            10\n        ],\n        fc: 15\n    },\n    {\n        lngs: [\n            \"lv\"\n        ],\n        nr: [\n            1,\n            2,\n            0\n        ],\n        fc: 16\n    },\n    {\n        lngs: [\n            \"mk\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 17\n    },\n    {\n        lngs: [\n            \"mnk\"\n        ],\n        nr: [\n            0,\n            1,\n            2\n        ],\n        fc: 18\n    },\n    {\n        lngs: [\n            \"mt\"\n        ],\n        nr: [\n            1,\n            2,\n            11,\n            20\n        ],\n        fc: 19\n    },\n    {\n        lngs: [\n            \"or\"\n        ],\n        nr: [\n            2,\n            1\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ro\"\n        ],\n        nr: [\n            1,\n            2,\n            20\n        ],\n        fc: 20\n    },\n    {\n        lngs: [\n            \"sl\"\n        ],\n        nr: [\n            5,\n            1,\n            2,\n            3\n        ],\n        fc: 21\n    },\n    {\n        lngs: [\n            \"he\",\n            \"iw\"\n        ],\n        nr: [\n            1,\n            2,\n            20,\n            21\n        ],\n        fc: 22\n    }\n];\nlet _rulesPluralsTypes = {\n    1: (n)=>Number(n > 1),\n    2: (n)=>Number(n != 1),\n    3: (n)=>0,\n    4: (n)=>Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),\n    5: (n)=>Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),\n    6: (n)=>Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),\n    7: (n)=>Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),\n    8: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),\n    9: (n)=>Number(n >= 2),\n    10: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),\n    11: (n)=>Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),\n    12: (n)=>Number(n % 10 != 1 || n % 100 == 11),\n    13: (n)=>Number(n !== 0),\n    14: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),\n    15: (n)=>Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),\n    16: (n)=>Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),\n    17: (n)=>Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),\n    18: (n)=>Number(n == 0 ? 0 : n == 1 ? 1 : 2),\n    19: (n)=>Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),\n    20: (n)=>Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),\n    21: (n)=>Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),\n    22: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)\n};\nconst nonIntlVersions = [\n    \"v1\",\n    \"v2\",\n    \"v3\"\n];\nconst intlVersions = [\n    \"v4\"\n];\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nconst createRules = ()=>{\n    const rules = {};\n    sets.forEach((set)=>{\n        set.lngs.forEach((l)=>{\n            rules[l] = {\n                numbers: set.nr,\n                plurals: _rulesPluralsTypes[set.fc]\n            };\n        });\n    });\n    return rules;\n};\nclass PluralResolver {\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    clearCache() {\n        this.pluralRulesCache = {};\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.shouldUseIntlApi()) {\n            try {\n                const cleanedCode = getCleanedCode(code === \"dev\" ? \"en\" : code);\n                const type = options.ordinal ? \"ordinal\" : \"cardinal\";\n                const cacheKey = JSON.stringify({\n                    cleanedCode,\n                    type\n                });\n                if (cacheKey in this.pluralRulesCache) {\n                    return this.pluralRulesCache[cacheKey];\n                }\n                const rule = new Intl.PluralRules(cleanedCode, {\n                    type\n                });\n                this.pluralRulesCache[cacheKey] = rule;\n                return rule;\n            } catch (err) {\n                return;\n            }\n        }\n        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (this.shouldUseIntlApi()) {\n            return rule && rule.resolvedOptions().pluralCategories.length > 1;\n        }\n        return rule && rule.numbers.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>\"\".concat(key).concat(suffix));\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (!rule) {\n            return [];\n        }\n        if (this.shouldUseIntlApi()) {\n            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>\"\".concat(this.options.prepend).concat(options.ordinal ? \"ordinal\".concat(this.options.prepend) : \"\").concat(pluralCategory));\n        }\n        return rule.numbers.map((number)=>this.getSuffix(code, number, options));\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            if (this.shouldUseIntlApi()) {\n                return \"\".concat(this.options.prepend).concat(options.ordinal ? \"ordinal\".concat(this.options.prepend) : \"\").concat(rule.select(count));\n            }\n            return this.getSuffixRetroCompatible(rule, count);\n        }\n        this.logger.warn(\"no plural rule found for: \".concat(code));\n        return \"\";\n    }\n    getSuffixRetroCompatible(rule, count) {\n        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        let suffix = rule.numbers[idx];\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            if (suffix === 2) {\n                suffix = \"plural\";\n            } else if (suffix === 1) {\n                suffix = \"\";\n            }\n        }\n        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n        if (this.options.compatibilityJSON === \"v1\") {\n            if (suffix === 1) return \"\";\n            if (typeof suffix === \"number\") return \"_plural_\".concat(suffix.toString());\n            return returnSuffix();\n        } else if (this.options.compatibilityJSON === \"v2\") {\n            return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            return returnSuffix();\n        }\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n    shouldUseIntlApi() {\n        return !nonIntlVersions.includes(this.options.compatibilityJSON);\n    }\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === \"undefined\" || !Intl.PluralRules)) {\n            this.options.compatibilityJSON = \"v3\";\n            this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\");\n        }\n        this.rules = createRules();\n        this.pluralRulesCache = {};\n    }\n}\nconst deepFindWithDefaults = function(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && typeof key === \"string\") {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n};\nconst regexSafe = (val)=>val.replace(/\\$/g, \"$$$$\");\nclass Interpolator {\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options.interpolation;\n        this.escape = escape$1 !== undefined ? escape$1 : escape;\n        this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || \"{{\";\n        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || \"}}\";\n        this.formatSeparator = formatSeparator || \",\";\n        this.unescapePrefix = unescapeSuffix ? \"\" : unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : unescapeSuffix || \"\";\n        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = nestingOptionsSeparator || \",\";\n        this.maxReplaces = maxReplaces || 1000;\n        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const getOrResetRegExp = (existingRegExp, pattern)=>{\n            if (existingRegExp && existingRegExp.source === pattern) {\n                existingRegExp.lastIndex = 0;\n                return existingRegExp;\n            }\n            return new RegExp(pattern, \"g\");\n        };\n        this.regexp = getOrResetRegExp(this.regexp, \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix));\n        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix));\n        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix));\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = typeof temp === \"string\" ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(\"missed to pass in variable \".concat(matchedVar, \" for interpolating \").concat(str));\n                        value = \"\";\n                    }\n                } else if (typeof value !== \"string\" && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        const handleHasOptions = (key, inheritedOptions)=>{\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(\"\".concat(sep, \"[ ]*{\")));\n            let optionsString = \"{\".concat(c[1]);\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(\"failed parsing options string in nesting for key \".concat(key), e);\n                return \"\".concat(key).concat(sep).concat(optionsString);\n            }\n            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n            return key;\n        };\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== \"string\" ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && typeof value !== \"string\") return value;\n            if (typeof value !== \"string\") value = makeString(value);\n            if (!value) {\n                this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options.interpolation && options.interpolation.format || ((value)=>value);\n        this.init(options);\n    }\n}\nconst parseFormatStr = (formatStr)=>{\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (opt) {\n                    const [key, ...rest] = opt.split(\":\");\n                    const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                    const trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === \"false\") formatOptions[trimmedKey] = false;\n                    if (val === \"true\") formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n};\nconst createCachedFormatter = (fn)=>{\n    const cache = {};\n    return (val, lng, options)=>{\n        let optForCache = options;\n        if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {\n            optForCache = {\n                ...optForCache,\n                [options.interpolationkey]: undefined\n            };\n        }\n        const key = lng + JSON.stringify(optForCache);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n};\nclass Formatter {\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        const iOpts = options.interpolation;\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        if (formats.length > 1 && formats[0].indexOf(\"(\") > 1 && formats[0].indexOf(\")\") < 0 && formats.find((f)=>f.indexOf(\")\") > -1)) {\n            const lastIndex = formats.findIndex((f)=>f.indexOf(\")\") > -1);\n            formats[0] = [\n                formats[0],\n                ...formats.splice(1, lastIndex)\n            ].join(this.formatSeparator);\n        }\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(\"there was no format function for \".concat(formatName));\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n}\nconst removePending = (q, name)=>{\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n};\nclass Connector extends EventEmitter {\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = \"\".concat(lng, \"|\").concat(ns);\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (!err && data) {\n            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                skipCopy: true\n            });\n        }\n        this.state[name] = err ? -1 : 2;\n        if (err && data) this.state[name] = 0;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (typeof languages === \"string\") languages = this.languageUtils.toResolveHierarchy(languages);\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(\"\".concat(prefix, \"loading namespace \").concat(ns, \" for language \").concat(lng, \" failed\"), err);\n            if (!err && data) this.logger.log(\"\".concat(prefix, \"loaded namespace \").concat(ns, \" for language \").concat(lng), data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n            this.logger.warn('did not save key \"'.concat(key, '\" as the namespace \"').concat(namespace, '\" was not yet loaded'), \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend && this.backend.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        if (this.backend && this.backend.init) {\n            this.backend.init(services, options.backend, options);\n        }\n    }\n}\nconst get = ()=>({\n        debug: false,\n        initImmediate: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: (args)=>{\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (typeof args[1] === \"string\") ret.defaultValue = args[1];\n            if (typeof args[2] === \"string\") ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    });\nconst transformOptions = (options)=>{\n    if (typeof options.ns === \"string\") options.ns = [\n        options.ns\n    ];\n    if (typeof options.fallbackLng === \"string\") options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (typeof options.fallbackNS === \"string\") options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs && options.supportedLngs.indexOf(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    return options;\n};\nconst noop = ()=>{};\nconst bindMemberFunctions = (inst)=>{\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n};\nclass I18n extends EventEmitter {\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        this.isInitializing = true;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n            if (typeof options.ns === \"string\") {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        if (this.options.compatibilityAPI !== \"v1\") {\n            this.options.interpolation = {\n                ...defOpts.interpolation,\n                ...this.options.interpolation\n            };\n        }\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        const createClassOnDemand = (ClassOrObject)=>{\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        };\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else if (typeof Intl !== \"undefined\") {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                compatibilityJSON: this.options.compatibilityJSON,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                this.isInitializing = false;\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && this.options.compatibilityAPI !== \"v1\" && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initImmediate) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = typeof language === \"string\" ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng && usedLng.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            if (this.options.preload) {\n                this.options.preload.forEach((l)=>append(l));\n            }\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"function\") {\n            callback = lngs;\n            lngs = undefined;\n        }\n        if (typeof ns === \"function\") {\n            callback = ns;\n            ns = undefined;\n        }\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = typeof lngs === \"string\" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            if (options.keyPrefix !== \"\") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>\"\".concat(options.keyPrefix).concat(keySeparator).concat(k));\n            } else {\n                resultKey = options.keyPrefix ? \"\".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (typeof lng === \"string\") {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        return this.translator && this.translator.translate(...arguments);\n    }\n    exists() {\n        return this.translator && this.translator.exists(...arguments);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n            return loadState === -1 || loadState === 0 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (typeof ns === \"string\") ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"string\") lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            clone.store = new ResourceStore(this.store.data, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n                args[_key4 - 1] = arguments[_key4];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initImmediate) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvZXNtL2kxOG5leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBTUEsZ0JBQWdCO0lBQ3BCQyxNQUFNO0lBQ05DLEtBQUlDLElBQUk7UUFDTixJQUFJLENBQUNDLE1BQU0sQ0FBQyxPQUFPRDtJQUNyQjtJQUNBRSxNQUFLRixJQUFJO1FBQ1AsSUFBSSxDQUFDQyxNQUFNLENBQUMsUUFBUUQ7SUFDdEI7SUFDQUcsT0FBTUgsSUFBSTtRQUNSLElBQUksQ0FBQ0MsTUFBTSxDQUFDLFNBQVNEO0lBQ3ZCO0lBQ0FDLFFBQU9ILElBQUksRUFBRUUsSUFBSTtRQUNmLElBQUlJLFdBQVdBLE9BQU8sQ0FBQ04sS0FBSyxFQUFFTSxPQUFPLENBQUNOLEtBQUssQ0FBQ08sS0FBSyxDQUFDRCxTQUFTSjtJQUM3RDtBQUNGO0FBQ0EsTUFBTU07SUFLSkMsS0FBS0MsY0FBYyxFQUFFO1FBQ25CLElBQUlDLFVBQVVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxDQUFDRyxNQUFNLEdBQUdKLFFBQVFJLE1BQU0sSUFBSTtRQUNoQyxJQUFJLENBQUNDLE1BQU0sR0FBR04sa0JBQWtCWDtRQUNoQyxJQUFJLENBQUNZLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNNLEtBQUssR0FBR04sUUFBUU0sS0FBSztJQUM1QjtJQUNBaEIsTUFBTTtRQUNKLElBQUssSUFBSWlCLE9BQU9OLFVBQVVDLE1BQU0sRUFBRVgsT0FBTyxJQUFJaUIsTUFBTUQsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1lBQ3ZGbEIsSUFBSSxDQUFDa0IsS0FBSyxHQUFHUixTQUFTLENBQUNRLEtBQUs7UUFDOUI7UUFDQSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDbkIsTUFBTSxP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LEtBQUtBLElBQUksT0FBTztJQUMxQyxJQUFJQSxDQUFBQSxJQUFLc0ssT0FBT3RLLE1BQU07SUFDdEIsSUFBSUEsQ0FBQUEsSUFBS3NLLE9BQU90SyxLQUFLLElBQUksSUFBSUEsS0FBSyxJQUFJLElBQUlBLEtBQUssSUFBSSxJQUFJO0lBQ3ZELElBQUlBLENBQUFBLElBQUtzSyxPQUFPdEssSUFBSSxNQUFNLEtBQUtBLElBQUksT0FBTyxLQUFLLElBQUlBLElBQUksTUFBTSxLQUFNQSxDQUFBQSxJQUFJLE1BQU0sTUFBTUEsSUFBSSxPQUFPLEVBQUMsSUFBSyxJQUFJO0lBQ3hHLElBQUlBLENBQUFBLElBQUtzSyxPQUFPdEssSUFBSSxNQUFNLEtBQUtBLElBQUksT0FBTyxLQUFLLElBQUlBLE1BQU0sSUFBSSxJQUFJO0lBQ2pFLElBQUlBLENBQUFBLElBQUtzSyxPQUFPdEssS0FBSyxLQUFLQSxJQUFJLE1BQU0sS0FBS0EsSUFBSSxPQUFPLEtBQUssSUFBSTtJQUM3RCxJQUFJQSxDQUFBQSxJQUFLc0ssT0FBT3RLLEtBQUssSUFBSSxJQUFJQSxLQUFLLElBQUksSUFBSTtJQUMxQyxJQUFJQSxDQUFBQSxJQUFLc0ssT0FBT3RLLEtBQUssSUFBSSxJQUFJQSxLQUFLLEtBQUtBLElBQUksTUFBTSxLQUFLQSxJQUFJLE1BQU0sS0FBSyxJQUFJQSxJQUFJLE1BQU0sTUFBTUEsSUFBSSxNQUFNLEtBQUssSUFBSTtJQUM1RyxJQUFJQSxDQUFBQSxJQUFLc0ssT0FBT3RLLEtBQUssSUFBSSxJQUFJQSxLQUFLLEtBQUtBLElBQUksTUFBTSxLQUFLQSxJQUFJLE1BQU0sS0FBSyxJQUFJO0lBQ3pFLElBQUlBLENBQUFBLElBQUtzSyxPQUFPdEssSUFBSSxPQUFPLElBQUksSUFBSUEsSUFBSSxPQUFPLElBQUksSUFBSUEsSUFBSSxPQUFPLEtBQUtBLElBQUksT0FBTyxJQUFJLElBQUk7SUFDekYsSUFBSUEsQ0FBQUEsSUFBS3NLLE9BQU90SyxLQUFLLElBQUksSUFBSUEsS0FBSyxJQUFJLElBQUksQ0FBQ0EsSUFB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QWdCVSxTQUFTVixhQUFhO0FBRWlLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvZXNtL2kxOG5leHQuanM/NjhlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb25zb2xlTG9nZ2VyID0ge1xuICB0eXBlOiAnbG9nZ2VyJyxcbiAgbG9nKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnbG9nJywgYXJncyk7XG4gIH0sXG4gIHdhcm4oYXJncykge1xuICAgIHRoaXMub3V0cHV0KCd3YXJuJywgYXJncyk7XG4gIH0sXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnZXJyb3InLCBhcmdzKTtcbiAgfSxcbiAgb3V0cHV0KHR5cGUsIGFyZ3MpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlW3R5cGVdKSBjb25zb2xlW3R5cGVdLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoY29uY3JldGVMb2dnZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5pbml0KGNvbmNyZXRlTG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxuICBpbml0KGNvbmNyZXRlTG9nZ2VyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgJ2kxOG5leHQ6JztcbiAgICB0aGlzLmxvZ2dlciA9IGNvbmNyZXRlTG9nZ2VyIHx8IGNvbnNvbGVMb2dnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgfVxuICBsb2coKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdsb2cnLCAnJywgdHJ1ZSk7XG4gIH1cbiAgd2FybigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICcnLCB0cnVlKTtcbiAgfVxuICBlcnJvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnZXJyb3InLCAnJyk7XG4gIH1cbiAgZGVwcmVjYXRlKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJ1dBUk5JTkcgREVQUkVDQVRFRDogJywgdHJ1ZSk7XG4gIH1cbiAgZm9yd2FyZChhcmdzLCBsdmwsIHByZWZpeCwgZGVidWdPbmx5KSB7XG4gICAgaWYgKGRlYnVnT25seSAmJiAhdGhpcy5kZWJ1ZykgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykgYXJnc1swXSA9IGAke3ByZWZpeH0ke3RoaXMucHJlZml4fSAke2FyZ3NbMF19YDtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJbbHZsXShhcmdzKTtcbiAgfVxuICBjcmVhdGUobW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCB7XG4gICAgICAuLi57XG4gICAgICAgIHByZWZpeDogYCR7dGhpcy5wcmVmaXh9OiR7bW9kdWxlTmFtZX06YFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNsb25lKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnM7XG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCB0aGlzLnByZWZpeDtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbn1cbnZhciBiYXNlTG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50cywgbGlzdGVuZXIpIHtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB0aGlzLm9ic2VydmVyc1tldmVudF0gPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBudW1MaXN0ZW5lcnMgPSB0aGlzLm9ic2VydmVyc1tldmVudF0uZ2V0KGxpc3RlbmVyKSB8fCAwO1xuICAgICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdLnNldChsaXN0ZW5lciwgbnVtTGlzdGVuZXJzICsgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSByZXR1cm47XG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5lbnRyaWVzKCkpO1xuICAgICAgY2xvbmVkLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICAgIGxldCBbb2JzZXJ2ZXIsIG51bVRpbWVzQWRkZWRdID0gX3JlZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lc0FkZGVkOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1snKiddKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXJzWycqJ10uZW50cmllcygpKTtcbiAgICAgIGNsb25lZC5mb3JFYWNoKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IFtvYnNlcnZlciwgbnVtVGltZXNBZGRlZF0gPSBfcmVmMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lc0FkZGVkOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlci5hcHBseShvYnNlcnZlciwgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkZWZlciA9ICgpID0+IHtcbiAgbGV0IHJlcztcbiAgbGV0IHJlajtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXMgPSByZXNvbHZlO1xuICAgIHJlaiA9IHJlamVjdDtcbiAgfSk7XG4gIHByb21pc2UucmVzb2x2ZSA9IHJlcztcbiAgcHJvbWlzZS5yZWplY3QgPSByZWo7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IG1ha2VTdHJpbmcgPSBvYmplY3QgPT4ge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuICcnICsgb2JqZWN0O1xufTtcbmNvbnN0IGNvcHkgPSAoYSwgcywgdCkgPT4ge1xuICBhLmZvckVhY2gobSA9PiB7XG4gICAgaWYgKHNbbV0pIHRbbV0gPSBzW21dO1xuICB9KTtcbn07XG5jb25zdCBsYXN0T2ZQYXRoU2VwYXJhdG9yUmVnRXhwID0gLyMjIy9nO1xuY29uc3QgY2xlYW5LZXkgPSBrZXkgPT4ga2V5ICYmIGtleS5pbmRleE9mKCcjIyMnKSA+IC0xID8ga2V5LnJlcGxhY2UobGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCwgJy4nKSA6IGtleTtcbmNvbnN0IGNhbk5vdFRyYXZlcnNlRGVlcGVyID0gb2JqZWN0ID0+ICFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZyc7XG5jb25zdCBnZXRMYXN0T2ZQYXRoID0gKG9iamVjdCwgcGF0aCwgRW1wdHkpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgc3RhY2tJbmRleCA9IDA7XG4gIHdoaWxlIChzdGFja0luZGV4IDwgc3RhY2subGVuZ3RoIC0gMSkge1xuICAgIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcihvYmplY3QpKSByZXR1cm4ge307XG4gICAgY29uc3Qga2V5ID0gY2xlYW5LZXkoc3RhY2tbc3RhY2tJbmRleF0pO1xuICAgIGlmICghb2JqZWN0W2tleV0gJiYgRW1wdHkpIG9iamVjdFtrZXldID0gbmV3IEVtcHR5KCk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSB7fTtcbiAgICB9XG4gICAgKytzdGFja0luZGV4O1xuICB9XG4gIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcihvYmplY3QpKSByZXR1cm4ge307XG4gIHJldHVybiB7XG4gICAgb2JqOiBvYmplY3QsXG4gICAgazogY2xlYW5LZXkoc3RhY2tbc3RhY2tJbmRleF0pXG4gIH07XG59O1xuY29uc3Qgc2V0UGF0aCA9IChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCB8fCBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIG9ialtrXSA9IG5ld1ZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgbGV0IHAgPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gIGxldCBsYXN0ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHAsIE9iamVjdCk7XG4gIHdoaWxlIChsYXN0Lm9iaiA9PT0gdW5kZWZpbmVkICYmIHAubGVuZ3RoKSB7XG4gICAgZSA9IGAke3BbcC5sZW5ndGggLSAxXX0uJHtlfWA7XG4gICAgcCA9IHAuc2xpY2UoMCwgcC5sZW5ndGggLSAxKTtcbiAgICBsYXN0ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHAsIE9iamVjdCk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdC5vYmogJiYgdHlwZW9mIGxhc3Qub2JqW2Ake2xhc3Qua30uJHtlfWBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbGFzdC5vYmogPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGxhc3Qub2JqW2Ake2xhc3Qua30uJHtlfWBdID0gbmV3VmFsdWU7XG59O1xuY29uc3QgcHVzaFBhdGggPSAob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSwgY29uY2F0KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIG9ialtrXSA9IG9ialtrXSB8fCBbXTtcbiAgb2JqW2tdLnB1c2gobmV3VmFsdWUpO1xufTtcbmNvbnN0IGdldFBhdGggPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgpO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG9ialtrXTtcbn07XG5jb25zdCBnZXRQYXRoV2l0aERlZmF1bHRzID0gKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpID0+IHtcbiAgY29uc3QgdmFsdWUgPSBnZXRQYXRoKGRhdGEsIGtleSk7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRQYXRoKGRlZmF1bHREYXRhLCBrZXkpO1xufTtcbmNvbnN0IGRlZXBFeHRlbmQgPSAodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkgPT4ge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgaWYgKHByb3AgIT09ICdfX3Byb3RvX18nICYmIHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtwcm9wXSA9PT0gJ3N0cmluZycgfHwgdGFyZ2V0W3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBzb3VyY2VbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHNvdXJjZVtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuY29uc3QgcmVnZXhFc2NhcGUgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG52YXIgX2VudGl0eU1hcCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgJy8nOiAnJiN4MkY7J1xufTtcbmNvbnN0IGVzY2FwZSA9IGRhdGEgPT4ge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgcyA9PiBfZW50aXR5TWFwW3NdKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5jbGFzcyBSZWdFeHBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMucmVnRXhwTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVnRXhwUXVldWUgPSBbXTtcbiAgfVxuICBnZXRSZWdFeHAocGF0dGVybikge1xuICAgIGNvbnN0IHJlZ0V4cEZyb21DYWNoZSA9IHRoaXMucmVnRXhwTWFwLmdldChwYXR0ZXJuKTtcbiAgICBpZiAocmVnRXhwRnJvbUNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZWdFeHBGcm9tQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHJlZ0V4cE5ldyA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgaWYgKHRoaXMucmVnRXhwUXVldWUubGVuZ3RoID09PSB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICB0aGlzLnJlZ0V4cE1hcC5kZWxldGUodGhpcy5yZWdFeHBRdWV1ZS5zaGlmdCgpKTtcbiAgICB9XG4gICAgdGhpcy5yZWdFeHBNYXAuc2V0KHBhdHRlcm4sIHJlZ0V4cE5ldyk7XG4gICAgdGhpcy5yZWdFeHBRdWV1ZS5wdXNoKHBhdHRlcm4pO1xuICAgIHJldHVybiByZWdFeHBOZXc7XG4gIH1cbn1cbmNvbnN0IGNoYXJzID0gWycgJywgJywnLCAnPycsICchJywgJzsnXTtcbmNvbnN0IGxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSA9IG5ldyBSZWdFeHBDYWNoZSgyMCk7XG5jb25zdCBsb29rc0xpa2VPYmplY3RQYXRoID0gKGtleSwgbnNTZXBhcmF0b3IsIGtleVNlcGFyYXRvcikgPT4ge1xuICBuc1NlcGFyYXRvciA9IG5zU2VwYXJhdG9yIHx8ICcnO1xuICBrZXlTZXBhcmF0b3IgPSBrZXlTZXBhcmF0b3IgfHwgJyc7XG4gIGNvbnN0IHBvc3NpYmxlQ2hhcnMgPSBjaGFycy5maWx0ZXIoYyA9PiBuc1NlcGFyYXRvci5pbmRleE9mKGMpIDwgMCAmJiBrZXlTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDApO1xuICBpZiAocG9zc2libGVDaGFycy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBjb25zdCByID0gbG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlLmdldFJlZ0V4cChgKCR7cG9zc2libGVDaGFycy5tYXAoYyA9PiBjID09PSAnPycgPyAnXFxcXD8nIDogYykuam9pbignfCcpfSlgKTtcbiAgbGV0IG1hdGNoZWQgPSAhci50ZXN0KGtleSk7XG4gIGlmICghbWF0Y2hlZCkge1xuICAgIGNvbnN0IGtpID0ga2V5LmluZGV4T2Yoa2V5U2VwYXJhdG9yKTtcbiAgICBpZiAoa2kgPiAwICYmICFyLnRlc3Qoa2V5LnN1YnN0cmluZygwLCBraSkpKSB7XG4gICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZWQ7XG59O1xuY29uc3QgZGVlcEZpbmQgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gIGxldCBrZXlTZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChvYmpbcGF0aF0pIHJldHVybiBvYmpbcGF0aF07XG4gIGNvbnN0IHRva2VucyA9IHBhdGguc3BsaXQoa2V5U2VwYXJhdG9yKTtcbiAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDspIHtcbiAgICBpZiAoIWN1cnJlbnQgfHwgdHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgbmV4dFBhdGggPSAnJztcbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRva2Vucy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGogIT09IGkpIHtcbiAgICAgICAgbmV4dFBhdGggKz0ga2V5U2VwYXJhdG9yO1xuICAgICAgfVxuICAgICAgbmV4dFBhdGggKz0gdG9rZW5zW2pdO1xuICAgICAgbmV4dCA9IGN1cnJlbnRbbmV4dFBhdGhdO1xuICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXS5pbmRleE9mKHR5cGVvZiBuZXh0KSA+IC0xICYmIGogPCB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gaiAtIGkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuY29uc3QgZ2V0Q2xlYW5lZENvZGUgPSBjb2RlID0+IHtcbiAgaWYgKGNvZGUgJiYgY29kZS5pbmRleE9mKCdfJykgPiAwKSByZXR1cm4gY29kZS5yZXBsYWNlKCdfJywgJy0nKTtcbiAgcmV0dXJuIGNvZGU7XG59O1xuXG5jbGFzcyBSZXNvdXJjZVN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBuczogWyd0cmFuc2xhdGlvbiddLFxuICAgICAgZGVmYXVsdE5TOiAndHJhbnNsYXRpb24nXG4gICAgfTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhZGROYW1lc3BhY2VzKG5zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5wdXNoKG5zKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTmFtZXNwYWNlcyhucykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcHRpb25zLm5zLmluZGV4T2YobnMpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVzb3VyY2UobG5nLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3QgaWdub3JlSlNPTlN0cnVjdHVyZSA9IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlIDogdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmU7XG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gW2xuZywgbnNdO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKC4uLmtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5U2VwYXJhdG9yKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKC4uLmtleS5zcGxpdChrZXlTZXBhcmF0b3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBnZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCk7XG4gICAgaWYgKCFyZXN1bHQgJiYgIW5zICYmICFrZXkgJiYgbG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBsbmcgPSBwYXRoWzBdO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgICAga2V5ID0gcGF0aC5zbGljZSgyKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgfHwgIWlnbm9yZUpTT05TdHJ1Y3R1cmUgfHwgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIGRlZXBGaW5kKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGFbbG5nXSAmJiB0aGlzLmRhdGFbbG5nXVtuc10sIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICBhZGRSZXNvdXJjZShsbmcsIG5zLCBrZXksIHZhbHVlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSkgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcbiAgICBpZiAobG5nLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICBwYXRoID0gbG5nLnNwbGl0KCcuJyk7XG4gICAgICB2YWx1ZSA9IG5zO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgIH1cbiAgICB0aGlzLmFkZE5hbWVzcGFjZXMobnMpO1xuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCB2YWx1ZSk7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIGtleSwgdmFsdWUpO1xuICB9XG4gIGFkZFJlc291cmNlcyhsbmcsIG5zLCByZXNvdXJjZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge1xuICAgICAgc2lsZW50OiBmYWxzZVxuICAgIH07XG4gICAgZm9yIChjb25zdCBtIGluIHJlc291cmNlcykge1xuICAgICAgaWYgKHR5cGVvZiByZXNvdXJjZXNbbV0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkocmVzb3VyY2VzW21dKSkgdGhpcy5hZGRSZXNvdXJjZShsbmcsIG5zLCBtLCByZXNvdXJjZXNbbV0sIHtcbiAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIHJlc291cmNlcyk7XG4gIH1cbiAgYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgcmVzb3VyY2VzLCBkZWVwLCBvdmVyd3JpdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge1xuICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgIHNraXBDb3B5OiBmYWxzZVxuICAgIH07XG4gICAgbGV0IHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgICAgZGVlcCA9IHJlc291cmNlcztcbiAgICAgIHJlc291cmNlcyA9IG5zO1xuICAgICAgbnMgPSBwYXRoWzFdO1xuICAgIH1cbiAgICB0aGlzLmFkZE5hbWVzcGFjZXMobnMpO1xuICAgIGxldCBwYWNrID0gZ2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgpIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5za2lwQ29weSkgcmVzb3VyY2VzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNvdXJjZXMpKTtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgZGVlcEV4dGVuZChwYWNrLCByZXNvdXJjZXMsIG92ZXJ3cml0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2sgPSB7XG4gICAgICAgIC4uLnBhY2ssXG4gICAgICAgIC4uLnJlc291cmNlc1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHBhY2spO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIHJlbW92ZVJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtsbmddW25zXTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVOYW1lc3BhY2VzKG5zKTtcbiAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCBsbmcsIG5zKTtcbiAgfVxuICBoYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucykgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSA9PT0gJ3YxJykgcmV0dXJuIHtcbiAgICAgIC4uLnt9LFxuICAgICAgLi4udGhpcy5nZXRSZXNvdXJjZShsbmcsIG5zKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucyk7XG4gIH1cbiAgZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtsbmddO1xuICB9XG4gIGhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmcpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhQnlMYW5ndWFnZShsbmcpO1xuICAgIGNvbnN0IG4gPSBkYXRhICYmIE9iamVjdC5rZXlzKGRhdGEpIHx8IFtdO1xuICAgIHJldHVybiAhIW4uZmluZCh2ID0+IGRhdGFbdl0gJiYgT2JqZWN0LmtleXMoZGF0YVt2XSkubGVuZ3RoID4gMCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxudmFyIHBvc3RQcm9jZXNzb3IgPSB7XG4gIHByb2Nlc3NvcnM6IHt9LFxuICBhZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSkge1xuICAgIHRoaXMucHJvY2Vzc29yc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG4gIH0sXG4gIGhhbmRsZShwcm9jZXNzb3JzLCB2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKSB7XG4gICAgcHJvY2Vzc29ycy5mb3JFYWNoKHByb2Nlc3NvciA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0pIHZhbHVlID0gdGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0ucHJvY2Vzcyh2YWx1ZSwga2V5LCBvcHRpb25zLCB0cmFuc2xhdG9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbmNvbnN0IGNoZWNrZWRMb2FkZWRGb3IgPSB7fTtcbmNsYXNzIFRyYW5zbGF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIGNvcHkoWydyZXNvdXJjZVN0b3JlJywgJ2xhbmd1YWdlVXRpbHMnLCAncGx1cmFsUmVzb2x2ZXInLCAnaW50ZXJwb2xhdG9yJywgJ2JhY2tlbmRDb25uZWN0b3InLCAnaTE4bkZvcm1hdCcsICd1dGlscyddLCBzZXJ2aWNlcywgdGhpcyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCd0cmFuc2xhdG9yJyk7XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nKSB7XG4gICAgaWYgKGxuZykgdGhpcy5sYW5ndWFnZSA9IGxuZztcbiAgfVxuICBleGlzdHMoa2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGludGVycG9sYXRpb246IHt9XG4gICAgfTtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKGtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGV4dHJhY3RGcm9tS2V5KGtleSwgb3B0aW9ucykge1xuICAgIGxldCBuc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgaWYgKG5zU2VwYXJhdG9yID09PSB1bmRlZmluZWQpIG5zU2VwYXJhdG9yID0gJzonO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgbGV0IG5hbWVzcGFjZXMgPSBvcHRpb25zLm5zIHx8IHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgfHwgW107XG4gICAgY29uc3Qgd291bGRDaGVja0Zvck5zSW5LZXkgPSBuc1NlcGFyYXRvciAmJiBrZXkuaW5kZXhPZihuc1NlcGFyYXRvcikgPiAtMTtcbiAgICBjb25zdCBzZWVtc05hdHVyYWxMYW5ndWFnZSA9ICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgJiYgIW9wdGlvbnMua2V5U2VwYXJhdG9yICYmICF0aGlzLm9wdGlvbnMudXNlckRlZmluZWROc1NlcGFyYXRvciAmJiAhb3B0aW9ucy5uc1NlcGFyYXRvciAmJiAhbG9va3NMaWtlT2JqZWN0UGF0aChrZXksIG5zU2VwYXJhdG9yLCBrZXlTZXBhcmF0b3IpO1xuICAgIGlmICh3b3VsZENoZWNrRm9yTnNJbktleSAmJiAhc2VlbXNOYXR1cmFsTGFuZ3VhZ2UpIHtcbiAgICAgIGNvbnN0IG0gPSBrZXkubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICBpZiAobSAmJiBtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmFtZXNwYWNlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQobnNTZXBhcmF0b3IpO1xuICAgICAgaWYgKG5zU2VwYXJhdG9yICE9PSBrZXlTZXBhcmF0b3IgfHwgbnNTZXBhcmF0b3IgPT09IGtleVNlcGFyYXRvciAmJiB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihwYXJ0c1swXSkgPiAtMSkgbmFtZXNwYWNlcyA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBrZXkgPSBwYXJ0cy5qb2luKGtleVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXNcbiAgICB9O1xuICB9XG4gIHRyYW5zbGF0ZShrZXlzLCBvcHRpb25zLCBsYXN0S2V5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cyA9PT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHRpb25zLnJldHVybkRldGFpbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmV0dXJuRGV0YWlscyA6IHRoaXMub3B0aW9ucy5yZXR1cm5EZXRhaWxzO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlc1xuICAgIH0gPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2U7XG4gICAgY29uc3QgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUgPSBvcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nICYmIGxuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGNvbnN0IG5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzOiBrZXksXG4gICAgICAgICAgdXNlZEtleToga2V5LFxuICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgIHVzZWRMbmc6IGxuZyxcbiAgICAgICAgICB1c2VkTlM6IG5hbWVzcGFjZSxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXlzLCBvcHRpb25zKTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzO1xuICAgIGNvbnN0IHJlc1VzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC51c2VkS2V5IHx8IGtleTtcbiAgICBjb25zdCByZXNFeGFjdFVzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlcyk7XG4gICAgY29uc3Qgbm9PYmplY3QgPSBbJ1tvYmplY3QgTnVtYmVyXScsICdbb2JqZWN0IEZ1bmN0aW9uXScsICdbb2JqZWN0IFJlZ0V4cF0nXTtcbiAgICBjb25zdCBqb2luQXJyYXlzID0gb3B0aW9ucy5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmpvaW5BcnJheXMgOiB0aGlzLm9wdGlvbnMuam9pbkFycmF5cztcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCA9ICF0aGlzLmkxOG5Gb3JtYXQgfHwgdGhpcy5pMThuRm9ybWF0LmhhbmRsZUFzT2JqZWN0O1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0ID0gdHlwZW9mIHJlcyAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHJlcyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZXMgIT09ICdudW1iZXInO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXMgJiYgaGFuZGxlQXNPYmplY3QgJiYgbm9PYmplY3QuaW5kZXhPZihyZXNUeXBlKSA8IDAgJiYgISh0eXBlb2Ygam9pbkFycmF5cyA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheShyZXMpKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnJldHVybk9iamVjdHMgJiYgIXRoaXMub3B0aW9ucy5yZXR1cm5PYmplY3RzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2FjY2Vzc2luZyBhbiBvYmplY3QgLSBidXQgcmV0dXJuT2JqZWN0cyBvcHRpb25zIGlzIG5vdCBlbmFibGVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyID8gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlcihyZXNVc2VkS2V5LCByZXMsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIG5zOiBuYW1lc3BhY2VzXG4gICAgICAgIH0pIDogYGtleSAnJHtrZXl9ICgke3RoaXMubGFuZ3VhZ2V9KScgcmV0dXJuZWQgYW4gb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nLmA7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmVzb2x2ZWQucmVzID0gcjtcbiAgICAgICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgICBpZiAoa2V5U2VwYXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlc1R5cGVJc0FycmF5ID0gQXJyYXkuaXNBcnJheShyZXMpO1xuICAgICAgICBjb25zdCBjb3B5ID0gcmVzVHlwZUlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBjb25zdCBuZXdLZXlUb1VzZSA9IHJlc1R5cGVJc0FycmF5ID8gcmVzRXhhY3RVc2VkS2V5IDogcmVzVXNlZEtleTtcbiAgICAgICAgZm9yIChjb25zdCBtIGluIHJlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzLCBtKSkge1xuICAgICAgICAgICAgY29uc3QgZGVlcEtleSA9IGAke25ld0tleVRvVXNlfSR7a2V5U2VwYXJhdG9yfSR7bX1gO1xuICAgICAgICAgICAgY29weVttXSA9IHRoaXMudHJhbnNsYXRlKGRlZXBLZXksIHtcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5zOiBuYW1lc3BhY2VzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvcHlbbV0gPT09IGRlZXBLZXkpIGNvcHlbbV0gPSByZXNbbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcyA9IGNvcHk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiB0eXBlb2Ygam9pbkFycmF5cyA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheShyZXMpKSB7XG4gICAgICByZXMgPSByZXMuam9pbihqb2luQXJyYXlzKTtcbiAgICAgIGlmIChyZXMpIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXlzLCBvcHRpb25zLCBsYXN0S2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVzZWREZWZhdWx0ID0gZmFsc2U7XG4gICAgICBsZXQgdXNlZEtleSA9IGZhbHNlO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBoYXNEZWZhdWx0VmFsdWUgPSBUcmFuc2xhdG9yLmhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVN1ZmZpeCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpIDogJyc7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2sgPSBvcHRpb25zLm9yZGluYWwgJiYgbmVlZHNQbHVyYWxIYW5kbGluZyA/IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGxuZywgb3B0aW9ucy5jb3VudCwge1xuICAgICAgICBvcmRpbmFsOiBmYWxzZVxuICAgICAgfSkgOiAnJztcbiAgICAgIGNvbnN0IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgJiYgIW9wdGlvbnMub3JkaW5hbCAmJiBvcHRpb25zLmNvdW50ID09PSAwICYmIHRoaXMucGx1cmFsUmVzb2x2ZXIuc2hvdWxkVXNlSW50bEFwaSgpO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gbmVlZHNaZXJvU3VmZml4TG9va3VwICYmIG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gfHwgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHtkZWZhdWx0VmFsdWVTdWZmaXh9YF0gfHwgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHtkZWZhdWx0VmFsdWVTdWZmaXhPcmRpbmFsRmFsbGJhY2t9YF0gfHwgb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChyZXMpICYmIGhhc0RlZmF1bHRWYWx1ZSkge1xuICAgICAgICB1c2VkRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIHJlcyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykpIHtcbiAgICAgICAgdXNlZEtleSA9IHRydWU7XG4gICAgICAgIHJlcyA9IGtleTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSA9IG9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5IHx8IHRoaXMub3B0aW9ucy5taXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXk7XG4gICAgICBjb25zdCByZXNGb3JNaXNzaW5nID0gbWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5ICYmIHVzZWRLZXkgPyB1bmRlZmluZWQgOiByZXM7XG4gICAgICBjb25zdCB1cGRhdGVNaXNzaW5nID0gaGFzRGVmYXVsdFZhbHVlICYmIGRlZmF1bHRWYWx1ZSAhPT0gcmVzICYmIHRoaXMub3B0aW9ucy51cGRhdGVNaXNzaW5nO1xuICAgICAgaWYgKHVzZWRLZXkgfHwgdXNlZERlZmF1bHQgfHwgdXBkYXRlTWlzc2luZykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2codXBkYXRlTWlzc2luZyA/ICd1cGRhdGVLZXknIDogJ21pc3NpbmdLZXknLCBsbmcsIG5hbWVzcGFjZSwga2V5LCB1cGRhdGVNaXNzaW5nID8gZGVmYXVsdFZhbHVlIDogcmVzKTtcbiAgICAgICAgaWYgKGtleVNlcGFyYXRvcikge1xuICAgICAgICAgIGNvbnN0IGZrID0gdGhpcy5yZXNvbHZlKGtleSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGtleVNlcGFyYXRvcjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZmsgJiYgZmsucmVzKSB0aGlzLmxvZ2dlci53YXJuKCdTZWVtcyB0aGUgbG9hZGVkIHRyYW5zbGF0aW9ucyB3ZXJlIGluIGZsYXQgSlNPTiBmb3JtYXQgaW5zdGVhZCBvZiBuZXN0ZWQuIEVpdGhlciBzZXQga2V5U2VwYXJhdG9yOiBmYWxzZSBvbiBpbml0IG9yIG1ha2Ugc3VyZSB5b3VyIHRyYW5zbGF0aW9ucyBhcmUgcHVibGlzaGVkIGluIG5lc3RlZCBmb3JtYXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxuZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tMbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nLCBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZ1RvID09PSAnZmFsbGJhY2snICYmIGZhbGxiYWNrTG5ncyAmJiBmYWxsYmFja0xuZ3NbMF0pIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhbGxiYWNrTG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbG5ncy5wdXNoKGZhbGxiYWNrTG5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZ1RvID09PSAnYWxsJykge1xuICAgICAgICAgIGxuZ3MgPSB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxuZ3MucHVzaChvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kID0gKGwsIGssIHNwZWNpZmljRGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEZvck1pc3NpbmcgPSBoYXNEZWZhdWx0VmFsdWUgJiYgc3BlY2lmaWNEZWZhdWx0VmFsdWUgIT09IHJlcyA/IHNwZWNpZmljRGVmYXVsdFZhbHVlIDogcmVzRm9yTWlzc2luZztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWlzc2luZ0tleUhhbmRsZXIobCwgbmFtZXNwYWNlLCBrLCBkZWZhdWx0Rm9yTWlzc2luZywgdXBkYXRlTWlzc2luZywgb3B0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmRDb25uZWN0b3IgJiYgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmRDb25uZWN0b3Iuc2F2ZU1pc3NpbmcobCwgbmFtZXNwYWNlLCBrLCBkZWZhdWx0Rm9yTWlzc2luZywgdXBkYXRlTWlzc2luZywgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgnbWlzc2luZ0tleScsIGwsIG5hbWVzcGFjZSwgaywgcmVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZykge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdQbHVyYWxzICYmIG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIGxuZ3MuZm9yRWFjaChsYW5ndWFnZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeGVzID0gdGhpcy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXhlcyhsYW5ndWFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXAgJiYgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gXSAmJiBzdWZmaXhlcy5pbmRleE9mKGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2ApIDwgMCkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeGVzLnB1c2goYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3VmZml4ZXMuZm9yRWFjaChzdWZmaXggPT4ge1xuICAgICAgICAgICAgICAgIHNlbmQoW2xhbmd1YWdlXSwga2V5ICsgc3VmZml4LCBvcHRpb25zW2BkZWZhdWx0VmFsdWUke3N1ZmZpeH1gXSB8fCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kKGxuZ3MsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXlzLCBvcHRpb25zLCByZXNvbHZlZCwgbGFzdEtleSk7XG4gICAgICBpZiAodXNlZEtleSAmJiByZXMgPT09IGtleSAmJiB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5KSByZXMgPSBgJHtuYW1lc3BhY2V9OiR7a2V5fWA7XG4gICAgICBpZiAoKHVzZWRLZXkgfHwgdXNlZERlZmF1bHQpICYmIHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSAhPT0gJ3YxJykge1xuICAgICAgICAgIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkgPyBgJHtuYW1lc3BhY2V9OiR7a2V5fWAgOiBrZXksIHVzZWREZWZhdWx0ID8gcmVzIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcihyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICByZXNvbHZlZC5yZXMgPSByZXM7XG4gICAgICByZXNvbHZlZC51c2VkUGFyYW1zID0gdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBleHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleSwgb3B0aW9ucywgcmVzb2x2ZWQsIGxhc3RLZXkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQgJiYgdGhpcy5pMThuRm9ybWF0LnBhcnNlKSB7XG4gICAgICByZXMgPSB0aGlzLmkxOG5Gb3JtYXQucGFyc2UocmVzLCB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0sIG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZywgcmVzb2x2ZWQudXNlZE5TLCByZXNvbHZlZC51c2VkS2V5LCB7XG4gICAgICAgIHJlc29sdmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNraXBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5pbml0KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ue1xuICAgICAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IHR5cGVvZiByZXMgPT09ICdzdHJpbmcnICYmIChvcHRpb25zICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXN0QmVmO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYiA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgbmVzdEJlZiA9IG5iICYmIG5iLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5yZXBsYWNlICYmIHR5cGVvZiBvcHRpb25zLnJlcGxhY2UgIT09ICdzdHJpbmcnID8gb3B0aW9ucy5yZXBsYWNlIDogb3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzKSBkYXRhID0ge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUocmVzLCBkYXRhLCBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlIHx8IHJlc29sdmVkLnVzZWRMbmcsIG9wdGlvbnMpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHRpb25zLm5lc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5sbmcgJiYgdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScgJiYgcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzKSBvcHRpb25zLmxuZyA9IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZztcbiAgICAgIGlmIChvcHRpb25zLm5lc3QgIT09IGZhbHNlKSByZXMgPSB0aGlzLmludGVycG9sYXRvci5uZXN0KHJlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0S2V5ICYmIGxhc3RLZXlbMF0gPT09IGFyZ3NbMF0gJiYgIW9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKGBJdCBzZWVtcyB5b3UgYXJlIG5lc3RpbmcgcmVjdXJzaXZlbHkga2V5OiAke2FyZ3NbMF19IGluIGtleTogJHtrZXlbMF19YCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zbGF0ZSguLi5hcmdzLCBrZXkpO1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5yZXNldCgpO1xuICAgIH1cbiAgICBjb25zdCBwb3N0UHJvY2VzcyA9IG9wdGlvbnMucG9zdFByb2Nlc3MgfHwgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzO1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzb3JOYW1lcyA9IHR5cGVvZiBwb3N0UHJvY2VzcyA9PT0gJ3N0cmluZycgPyBbcG9zdFByb2Nlc3NdIDogcG9zdFByb2Nlc3M7XG4gICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkICYmIHJlcyAhPT0gbnVsbCAmJiBwb3N0UHJvY2Vzc29yTmFtZXMgJiYgcG9zdFByb2Nlc3Nvck5hbWVzLmxlbmd0aCAmJiBvcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciAhPT0gZmFsc2UpIHtcbiAgICAgIHJlcyA9IHBvc3RQcm9jZXNzb3IuaGFuZGxlKHBvc3RQcm9jZXNzb3JOYW1lcywgcmVzLCBrZXksIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQgPyB7XG4gICAgICAgIGkxOG5SZXNvbHZlZDoge1xuICAgICAgICAgIC4uLnJlc29sdmVkLFxuICAgICAgICAgIHVzZWRQYXJhbXM6IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucylcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSA6IG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJlc29sdmUoa2V5cykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgZm91bmQ7XG4gICAgbGV0IHVzZWRLZXk7XG4gICAgbGV0IGV4YWN0VXNlZEtleTtcbiAgICBsZXQgdXNlZExuZztcbiAgICBsZXQgdXNlZE5TO1xuICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ3N0cmluZycpIGtleXMgPSBba2V5c107XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHRoaXMuZXh0cmFjdEZyb21LZXkoaywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBrZXkgPSBleHRyYWN0ZWQua2V5O1xuICAgICAgdXNlZEtleSA9IGtleTtcbiAgICAgIGxldCBuYW1lc3BhY2VzID0gZXh0cmFjdGVkLm5hbWVzcGFjZXM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZhbGxiYWNrTlMpIG5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzLmNvbmNhdCh0aGlzLm9wdGlvbnMuZmFsbGJhY2tOUyk7XG4gICAgICBjb25zdCBuZWVkc1BsdXJhbEhhbmRsaW5nID0gb3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmNvdW50ICE9PSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCA9IG5lZWRzUGx1cmFsSGFuZGxpbmcgJiYgIW9wdGlvbnMub3JkaW5hbCAmJiBvcHRpb25zLmNvdW50ID09PSAwICYmIHRoaXMucGx1cmFsUmVzb2x2ZXIuc2hvdWxkVXNlSW50bEFwaSgpO1xuICAgICAgY29uc3QgbmVlZHNDb250ZXh0SGFuZGxpbmcgPSBvcHRpb25zLmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ251bWJlcicpICYmIG9wdGlvbnMuY29udGV4dCAhPT0gJyc7XG4gICAgICBjb25zdCBjb2RlcyA9IG9wdGlvbnMubG5ncyA/IG9wdGlvbnMubG5ncyA6IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSwgb3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkgcmV0dXJuO1xuICAgICAgICB1c2VkTlMgPSBucztcbiAgICAgICAgaWYgKCFjaGVja2VkTG9hZGVkRm9yW2Ake2NvZGVzWzBdfS0ke25zfWBdICYmIHRoaXMudXRpbHMgJiYgdGhpcy51dGlscy5oYXNMb2FkZWROYW1lc3BhY2UgJiYgIXRoaXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlKHVzZWROUykpIHtcbiAgICAgICAgICBjaGVja2VkTG9hZGVkRm9yW2Ake2NvZGVzWzBdfS0ke25zfWBdID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBrZXkgXCIke3VzZWRLZXl9XCIgZm9yIGxhbmd1YWdlcyBcIiR7Y29kZXMuam9pbignLCAnKX1cIiB3b24ndCBnZXQgcmVzb2x2ZWQgYXMgbmFtZXNwYWNlIFwiJHt1c2VkTlN9XCIgd2FzIG5vdCB5ZXQgbG9hZGVkYCwgJ1RoaXMgbWVhbnMgc29tZXRoaW5nIElTIFdST05HIGluIHlvdXIgc2V0dXAuIFlvdSBhY2Nlc3MgdGhlIHQgZnVuY3Rpb24gYmVmb3JlIGkxOG5leHQuaW5pdCAvIGkxOG5leHQubG9hZE5hbWVzcGFjZSAvIGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2Ugd2FzIGRvbmUuIFdhaXQgZm9yIHRoZSBjYWxsYmFjayBvciBQcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGFjY2Vzc2luZyBpdCEhIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgICB1c2VkTG5nID0gY29kZTtcbiAgICAgICAgICBjb25zdCBmaW5hbEtleXMgPSBba2V5XTtcbiAgICAgICAgICBpZiAodGhpcy5pMThuRm9ybWF0ICYmIHRoaXMuaTE4bkZvcm1hdC5hZGRMb29rdXBLZXlzKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5Gb3JtYXQuYWRkTG9va3VwS2V5cyhmaW5hbEtleXMsIGtleSwgY29kZSwgbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGNvZGUsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgemVyb1N1ZmZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2A7XG4gICAgICAgICAgICBjb25zdCBvcmRpbmFsUHJlZml4ID0gYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1vcmRpbmFsJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfWA7XG4gICAgICAgICAgICBpZiAobmVlZHNQbHVyYWxIYW5kbGluZykge1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtrZXl9JHt0aGlzLm9wdGlvbnMuY29udGV4dFNlcGFyYXRvcn0ke29wdGlvbnMuY29udGV4dH1gO1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5KTtcbiAgICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgemVyb1N1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwb3NzaWJsZUtleTtcbiAgICAgICAgICB3aGlsZSAocG9zc2libGVLZXkgPSBmaW5hbEtleXMucG9wKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkge1xuICAgICAgICAgICAgICBleGFjdFVzZWRLZXkgPSBwb3NzaWJsZUtleTtcbiAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmdldFJlc291cmNlKGNvZGUsIG5zLCBwb3NzaWJsZUtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXM6IGZvdW5kLFxuICAgICAgdXNlZEtleSxcbiAgICAgIGV4YWN0VXNlZEtleSxcbiAgICAgIHVzZWRMbmcsXG4gICAgICB1c2VkTlNcbiAgICB9O1xuICB9XG4gIGlzVmFsaWRMb29rdXAocmVzKSB7XG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5OdWxsICYmIHJlcyA9PT0gbnVsbCkgJiYgISghdGhpcy5vcHRpb25zLnJldHVybkVtcHR5U3RyaW5nICYmIHJlcyA9PT0gJycpO1xuICB9XG4gIGdldFJlc291cmNlKGNvZGUsIG5zLCBrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQuZ2V0UmVzb3VyY2UpIHJldHVybiB0aGlzLmkxOG5Gb3JtYXQuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VTdG9yZS5nZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zKTtcbiAgfVxuICBnZXRVc2VkUGFyYW1zRGV0YWlscygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qgb3B0aW9uc0tleXMgPSBbJ2RlZmF1bHRWYWx1ZScsICdvcmRpbmFsJywgJ2NvbnRleHQnLCAncmVwbGFjZScsICdsbmcnLCAnbG5ncycsICdmYWxsYmFja0xuZycsICducycsICdrZXlTZXBhcmF0b3InLCAnbnNTZXBhcmF0b3InLCAncmV0dXJuT2JqZWN0cycsICdyZXR1cm5EZXRhaWxzJywgJ2pvaW5BcnJheXMnLCAncG9zdFByb2Nlc3MnLCAnaW50ZXJwb2xhdGlvbiddO1xuICAgIGNvbnN0IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2Ygb3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJztcbiAgICBsZXQgZGF0YSA9IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgaWYgKHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcykge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzdGF0aWMgaGFzRGVmYXVsdFZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnZGVmYXVsdFZhbHVlJztcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikgJiYgcHJlZml4ID09PSBvcHRpb24uc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpICYmIHVuZGVmaW5lZCAhPT0gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgY2FwaXRhbGl6ZSA9IHN0cmluZyA9PiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG5jbGFzcyBMYW5ndWFnZVV0aWwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN1cHBvcnRlZExuZ3MgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdsYW5ndWFnZVV0aWxzJyk7XG4gIH1cbiAgZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHJldHVybiBudWxsO1xuICAgIHAucG9wKCk7XG4gICAgaWYgKHBbcC5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpID09PSAneCcpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwLmpvaW4oJy0nKSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gY29kZTtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwWzBdKTtcbiAgfVxuICBmb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkge1xuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgJiYgY29kZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgY29uc3Qgc3BlY2lhbENhc2VzID0gWydoYW5zJywgJ2hhbnQnLCAnbGF0bicsICdjeXJsJywgJ2NhbnMnLCAnbW9uZycsICdhcmFiJ107XG4gICAgICBsZXQgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHAgPSBwLm1hcChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzcGVjaWFsQ2FzZXMuaW5kZXhPZihwWzFdLnRvTG93ZXJDYXNlKCkpID4gLTEpIHBbMV0gPSBjYXBpdGFsaXplKHBbMV0udG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzFdLmxlbmd0aCA9PT0gMikgcFsxXSA9IHBbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBbMF0gIT09ICdzZ24nICYmIHBbMl0ubGVuZ3RoID09PSAyKSBwWzJdID0gcFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsyXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzJdID0gY2FwaXRhbGl6ZShwWzJdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAuam9pbignLScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsZWFuQ29kZSB8fCB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nID8gY29kZS50b0xvd2VyQ2FzZSgpIDogY29kZTtcbiAgfVxuICBpc1N1cHBvcnRlZENvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCA9PT0gJ2xhbmd1YWdlT25seScgfHwgdGhpcy5vcHRpb25zLm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5zdXBwb3J0ZWRMbmdzIHx8ICF0aGlzLnN1cHBvcnRlZExuZ3MubGVuZ3RoIHx8IHRoaXMuc3VwcG9ydGVkTG5ncy5pbmRleE9mKGNvZGUpID4gLTE7XG4gIH1cbiAgZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGNvZGVzKSB7XG4gICAgaWYgKCFjb2RlcykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kO1xuICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgIGNvbnN0IGNsZWFuZWRMbmcgPSB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgdGhpcy5pc1N1cHBvcnRlZENvZGUoY2xlYW5lZExuZykpIGZvdW5kID0gY2xlYW5lZExuZztcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kICYmIHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPiAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCAmJiBzdXBwb3J0ZWRMbmcuc3Vic3RyaW5nKDAsIHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykpID09PSBsbmdPbmx5KSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZihsbmdPbmx5KSA9PT0gMCAmJiBsbmdPbmx5Lmxlbmd0aCA+IDEpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZm91bmQpIGZvdW5kID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZylbMF07XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tzLCBjb2RlKSB7XG4gICAgaWYgKCFmYWxsYmFja3MpIHJldHVybiBbXTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgZmFsbGJhY2tzID0gZmFsbGJhY2tzKGNvZGUpO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2tzID09PSAnc3RyaW5nJykgZmFsbGJhY2tzID0gW2ZhbGxiYWNrc107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkgcmV0dXJuIGZhbGxiYWNrcztcbiAgICBpZiAoIWNvZGUpIHJldHVybiBmYWxsYmFja3MuZGVmYXVsdCB8fCBbXTtcbiAgICBsZXQgZm91bmQgPSBmYWxsYmFja3NbY29kZV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5nZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrcy5kZWZhdWx0O1xuICAgIHJldHVybiBmb3VuZCB8fCBbXTtcbiAgfVxuICB0b1Jlc29sdmVIaWVyYXJjaHkoY29kZSwgZmFsbGJhY2tDb2RlKSB7XG4gICAgY29uc3QgZmFsbGJhY2tDb2RlcyA9IHRoaXMuZ2V0RmFsbGJhY2tDb2RlcyhmYWxsYmFja0NvZGUgfHwgdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIHx8IFtdLCBjb2RlKTtcbiAgICBjb25zdCBjb2RlcyA9IFtdO1xuICAgIGNvbnN0IGFkZENvZGUgPSBjID0+IHtcbiAgICAgIGlmICghYykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGMpKSB7XG4gICAgICAgIGNvZGVzLnB1c2goYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGByZWplY3RpbmcgbGFuZ3VhZ2UgY29kZSBub3QgZm91bmQgaW4gc3VwcG9ydGVkTG5nczogJHtjfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJyAmJiAoY29kZS5pbmRleE9mKCctJykgPiAtMSB8fCBjb2RlLmluZGV4T2YoJ18nKSA+IC0xKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JykgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknICYmIHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgfVxuICAgIGZhbGxiYWNrQ29kZXMuZm9yRWFjaChmYyA9PiB7XG4gICAgICBpZiAoY29kZXMuaW5kZXhPZihmYykgPCAwKSBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGZjKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvZGVzO1xuICB9XG59XG5cbmxldCBzZXRzID0gW3tcbiAgbG5nczogWydhY2gnLCAnYWsnLCAnYW0nLCAnYXJuJywgJ2JyJywgJ2ZpbCcsICdndW4nLCAnbG4nLCAnbWZlJywgJ21nJywgJ21pJywgJ29jJywgJ3B0JywgJ3B0LUJSJywgJ3RnJywgJ3RsJywgJ3RpJywgJ3RyJywgJ3V6JywgJ3dhJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxXG59LCB7XG4gIGxuZ3M6IFsnYWYnLCAnYW4nLCAnYXN0JywgJ2F6JywgJ2JnJywgJ2JuJywgJ2NhJywgJ2RhJywgJ2RlJywgJ2RldicsICdlbCcsICdlbicsICdlbycsICdlcycsICdldCcsICdldScsICdmaScsICdmbycsICdmdXInLCAnZnknLCAnZ2wnLCAnZ3UnLCAnaGEnLCAnaGknLCAnaHUnLCAnaHknLCAnaWEnLCAnaXQnLCAna2snLCAna24nLCAna3UnLCAnbGInLCAnbWFpJywgJ21sJywgJ21uJywgJ21yJywgJ25haCcsICduYXAnLCAnbmInLCAnbmUnLCAnbmwnLCAnbm4nLCAnbm8nLCAnbnNvJywgJ3BhJywgJ3BhcCcsICdwbXMnLCAncHMnLCAncHQtUFQnLCAncm0nLCAnc2NvJywgJ3NlJywgJ3NpJywgJ3NvJywgJ3NvbicsICdzcScsICdzdicsICdzdycsICd0YScsICd0ZScsICd0aycsICd1cicsICd5byddLFxuICBucjogWzEsIDJdLFxuICBmYzogMlxufSwge1xuICBsbmdzOiBbJ2F5JywgJ2JvJywgJ2NnZycsICdmYScsICdodCcsICdpZCcsICdqYScsICdqYm8nLCAna2EnLCAna20nLCAna28nLCAna3knLCAnbG8nLCAnbXMnLCAnc2FoJywgJ3N1JywgJ3RoJywgJ3R0JywgJ3VnJywgJ3ZpJywgJ3dvJywgJ3poJ10sXG4gIG5yOiBbMV0sXG4gIGZjOiAzXG59LCB7XG4gIGxuZ3M6IFsnYmUnLCAnYnMnLCAnY25yJywgJ2R6JywgJ2hyJywgJ3J1JywgJ3NyJywgJ3VrJ10sXG4gIG5yOiBbMSwgMiwgNV0sXG4gIGZjOiA0XG59LCB7XG4gIGxuZ3M6IFsnYXInXSxcbiAgbnI6IFswLCAxLCAyLCAzLCAxMSwgMTAwXSxcbiAgZmM6IDVcbn0sIHtcbiAgbG5nczogWydjcycsICdzayddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogNlxufSwge1xuICBsbmdzOiBbJ2NzYicsICdwbCddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogN1xufSwge1xuICBsbmdzOiBbJ2N5J10sXG4gIG5yOiBbMSwgMiwgMywgOF0sXG4gIGZjOiA4XG59LCB7XG4gIGxuZ3M6IFsnZnInXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDlcbn0sIHtcbiAgbG5nczogWydnYSddLFxuICBucjogWzEsIDIsIDMsIDcsIDExXSxcbiAgZmM6IDEwXG59LCB7XG4gIGxuZ3M6IFsnZ2QnXSxcbiAgbnI6IFsxLCAyLCAzLCAyMF0sXG4gIGZjOiAxMVxufSwge1xuICBsbmdzOiBbJ2lzJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxMlxufSwge1xuICBsbmdzOiBbJ2p2J10sXG4gIG5yOiBbMCwgMV0sXG4gIGZjOiAxM1xufSwge1xuICBsbmdzOiBbJ2t3J10sXG4gIG5yOiBbMSwgMiwgMywgNF0sXG4gIGZjOiAxNFxufSwge1xuICBsbmdzOiBbJ2x0J10sXG4gIG5yOiBbMSwgMiwgMTBdLFxuICBmYzogMTVcbn0sIHtcbiAgbG5nczogWydsdiddLFxuICBucjogWzEsIDIsIDBdLFxuICBmYzogMTZcbn0sIHtcbiAgbG5nczogWydtayddLFxuICBucjogWzEsIDJdLFxuICBmYzogMTdcbn0sIHtcbiAgbG5nczogWydtbmsnXSxcbiAgbnI6IFswLCAxLCAyXSxcbiAgZmM6IDE4XG59LCB7XG4gIGxuZ3M6IFsnbXQnXSxcbiAgbnI6IFsxLCAyLCAxMSwgMjBdLFxuICBmYzogMTlcbn0sIHtcbiAgbG5nczogWydvciddLFxuICBucjogWzIsIDFdLFxuICBmYzogMlxufSwge1xuICBsbmdzOiBbJ3JvJ10sXG4gIG5yOiBbMSwgMiwgMjBdLFxuICBmYzogMjBcbn0sIHtcbiAgbG5nczogWydzbCddLFxuICBucjogWzUsIDEsIDIsIDNdLFxuICBmYzogMjFcbn0sIHtcbiAgbG5nczogWydoZScsICdpdyddLFxuICBucjogWzEsIDIsIDIwLCAyMV0sXG4gIGZjOiAyMlxufV07XG5sZXQgX3J1bGVzUGx1cmFsc1R5cGVzID0ge1xuICAxOiBuID0+IE51bWJlcihuID4gMSksXG4gIDI6IG4gPT4gTnVtYmVyKG4gIT0gMSksXG4gIDM6IG4gPT4gMCxcbiAgNDogbiA9PiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwMCA8IDEwIHx8IG4gJSAxMDAgPj0gMjApID8gMSA6IDIpLFxuICA1OiBuID0+IE51bWJlcihuID09IDAgPyAwIDogbiA9PSAxID8gMSA6IG4gPT0gMiA/IDIgOiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCA/IDMgOiBuICUgMTAwID49IDExID8gNCA6IDUpLFxuICA2OiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA+PSAyICYmIG4gPD0gNCA/IDEgOiAyKSxcbiAgNzogbiA9PiBOdW1iZXIobiA9PSAxID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMiksXG4gIDg6IG4gPT4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiAhPSA4ICYmIG4gIT0gMTEgPyAyIDogMyksXG4gIDk6IG4gPT4gTnVtYmVyKG4gPj0gMiksXG4gIDEwOiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPCA3ID8gMiA6IG4gPCAxMSA/IDMgOiA0KSxcbiAgMTE6IG4gPT4gTnVtYmVyKG4gPT0gMSB8fCBuID09IDExID8gMCA6IG4gPT0gMiB8fCBuID09IDEyID8gMSA6IG4gPiAyICYmIG4gPCAyMCA/IDIgOiAzKSxcbiAgMTI6IG4gPT4gTnVtYmVyKG4gJSAxMCAhPSAxIHx8IG4gJSAxMDAgPT0gMTEpLFxuICAxMzogbiA9PiBOdW1iZXIobiAhPT0gMCksXG4gIDE0OiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPT0gMyA/IDIgOiAzKSxcbiAgMTU6IG4gPT4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAlIDEwID49IDIgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKSxcbiAgMTY6IG4gPT4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAhPT0gMCA/IDEgOiAyKSxcbiAgMTc6IG4gPT4gTnVtYmVyKG4gPT0gMSB8fCBuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IDEpLFxuICAxODogbiA9PiBOdW1iZXIobiA9PSAwID8gMCA6IG4gPT0gMSA/IDEgOiAyKSxcbiAgMTk6IG4gPT4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDAgfHwgbiAlIDEwMCA+IDEgJiYgbiAlIDEwMCA8IDExID8gMSA6IG4gJSAxMDAgPiAxMCAmJiBuICUgMTAwIDwgMjAgPyAyIDogMyksXG4gIDIwOiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA9PSAwIHx8IG4gJSAxMDAgPiAwICYmIG4gJSAxMDAgPCAyMCA/IDEgOiAyKSxcbiAgMjE6IG4gPT4gTnVtYmVyKG4gJSAxMDAgPT0gMSA/IDEgOiBuICUgMTAwID09IDIgPyAyIDogbiAlIDEwMCA9PSAzIHx8IG4gJSAxMDAgPT0gNCA/IDMgOiAwKSxcbiAgMjI6IG4gPT4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogKG4gPCAwIHx8IG4gPiAxMCkgJiYgbiAlIDEwID09IDAgPyAyIDogMylcbn07XG5jb25zdCBub25JbnRsVmVyc2lvbnMgPSBbJ3YxJywgJ3YyJywgJ3YzJ107XG5jb25zdCBpbnRsVmVyc2lvbnMgPSBbJ3Y0J107XG5jb25zdCBzdWZmaXhlc09yZGVyID0ge1xuICB6ZXJvOiAwLFxuICBvbmU6IDEsXG4gIHR3bzogMixcbiAgZmV3OiAzLFxuICBtYW55OiA0LFxuICBvdGhlcjogNVxufTtcbmNvbnN0IGNyZWF0ZVJ1bGVzID0gKCkgPT4ge1xuICBjb25zdCBydWxlcyA9IHt9O1xuICBzZXRzLmZvckVhY2goc2V0ID0+IHtcbiAgICBzZXQubG5ncy5mb3JFYWNoKGwgPT4ge1xuICAgICAgcnVsZXNbbF0gPSB7XG4gICAgICAgIG51bWJlcnM6IHNldC5ucixcbiAgICAgICAgcGx1cmFsczogX3J1bGVzUGx1cmFsc1R5cGVzW3NldC5mY11cbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcnVsZXM7XG59O1xuY2xhc3MgUGx1cmFsUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZVV0aWxzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IGxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdwbHVyYWxSZXNvbHZlcicpO1xuICAgIGlmICgoIXRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiB8fCBpbnRsVmVyc2lvbnMuaW5jbHVkZXModGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OKSkgJiYgKHR5cGVvZiBJbnRsID09PSAndW5kZWZpbmVkJyB8fCAhSW50bC5QbHVyYWxSdWxlcykpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiA9ICd2Myc7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignWW91ciBlbnZpcm9ubWVudCBzZWVtcyBub3QgdG8gYmUgSW50bCBBUEkgY29tcGF0aWJsZSwgdXNlIGFuIEludGwuUGx1cmFsUnVsZXMgcG9seWZpbGwuIFdpbGwgZmFsbGJhY2sgdG8gdGhlIGNvbXBhdGliaWxpdHlKU09OIHYzIGZvcm1hdCBoYW5kbGluZy4nKTtcbiAgICB9XG4gICAgdGhpcy5ydWxlcyA9IGNyZWF0ZVJ1bGVzKCk7XG4gICAgdGhpcy5wbHVyYWxSdWxlc0NhY2hlID0ge307XG4gIH1cbiAgYWRkUnVsZShsbmcsIG9iaikge1xuICAgIHRoaXMucnVsZXNbbG5nXSA9IG9iajtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMucGx1cmFsUnVsZXNDYWNoZSA9IHt9O1xuICB9XG4gIGdldFJ1bGUoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRDb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSA9PT0gJ2RldicgPyAnZW4nIDogY29kZSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLm9yZGluYWwgPyAnb3JkaW5hbCcgOiAnY2FyZGluYWwnO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjbGVhbmVkQ29kZSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FjaGVLZXkgaW4gdGhpcy5wbHVyYWxSdWxlc0NhY2hlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1cmFsUnVsZXNDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVsZSA9IG5ldyBJbnRsLlBsdXJhbFJ1bGVzKGNsZWFuZWRDb2RlLCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbHVyYWxSdWxlc0NhY2hlW2NhY2hlS2V5XSA9IHJ1bGU7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucnVsZXNbY29kZV0gfHwgdGhpcy5ydWxlc1t0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICB9XG4gIG5lZWRzUGx1cmFsKGNvZGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHJldHVybiBydWxlICYmIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZSAmJiBydWxlLm51bWJlcnMubGVuZ3RoID4gMTtcbiAgfVxuICBnZXRQbHVyYWxGb3Jtc09mS2V5KGNvZGUsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdWZmaXhlcyhjb2RlLCBvcHRpb25zKS5tYXAoc3VmZml4ID0+IGAke2tleX0ke3N1ZmZpeH1gKTtcbiAgfVxuICBnZXRTdWZmaXhlcyhjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgcmV0dXJuIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5zb3J0KChwbHVyYWxDYXRlZ29yeTEsIHBsdXJhbENhdGVnb3J5MikgPT4gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTFdIC0gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTJdKS5tYXAocGx1cmFsQ2F0ZWdvcnkgPT4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cGx1cmFsQ2F0ZWdvcnl9YCk7XG4gICAgfVxuICAgIHJldHVybiBydWxlLm51bWJlcnMubWFwKG51bWJlciA9PiB0aGlzLmdldFN1ZmZpeChjb2RlLCBudW1iZXIsIG9wdGlvbnMpKTtcbiAgfVxuICBnZXRTdWZmaXgoY29kZSwgY291bnQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMucHJlcGVuZH0ke29wdGlvbnMub3JkaW5hbCA/IGBvcmRpbmFsJHt0aGlzLm9wdGlvbnMucHJlcGVuZH1gIDogJyd9JHtydWxlLnNlbGVjdChjb3VudCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeFJldHJvQ29tcGF0aWJsZShydWxlLCBjb3VudCk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oYG5vIHBsdXJhbCBydWxlIGZvdW5kIGZvcjogJHtjb2RlfWApO1xuICAgIHJldHVybiAnJztcbiAgfVxuICBnZXRTdWZmaXhSZXRyb0NvbXBhdGlibGUocnVsZSwgY291bnQpIHtcbiAgICBjb25zdCBpZHggPSBydWxlLm5vQWJzID8gcnVsZS5wbHVyYWxzKGNvdW50KSA6IHJ1bGUucGx1cmFscyhNYXRoLmFicyhjb3VudCkpO1xuICAgIGxldCBzdWZmaXggPSBydWxlLm51bWJlcnNbaWR4XTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4ICYmIHJ1bGUubnVtYmVycy5sZW5ndGggPT09IDIgJiYgcnVsZS5udW1iZXJzWzBdID09PSAxKSB7XG4gICAgICBpZiAoc3VmZml4ID09PSAyKSB7XG4gICAgICAgIHN1ZmZpeCA9ICdwbHVyYWwnO1xuICAgICAgfSBlbHNlIGlmIChzdWZmaXggPT09IDEpIHtcbiAgICAgICAgc3VmZml4ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJldHVyblN1ZmZpeCA9ICgpID0+IHRoaXMub3B0aW9ucy5wcmVwZW5kICYmIHN1ZmZpeC50b1N0cmluZygpID8gdGhpcy5vcHRpb25zLnByZXBlbmQgKyBzdWZmaXgudG9TdHJpbmcoKSA6IHN1ZmZpeC50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MScpIHtcbiAgICAgIGlmIChzdWZmaXggPT09IDEpIHJldHVybiAnJztcbiAgICAgIGlmICh0eXBlb2Ygc3VmZml4ID09PSAnbnVtYmVyJykgcmV0dXJuIGBfcGx1cmFsXyR7c3VmZml4LnRvU3RyaW5nKCl9YDtcbiAgICAgIHJldHVybiByZXR1cm5TdWZmaXgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiA9PT0gJ3YyJykge1xuICAgICAgcmV0dXJuIHJldHVyblN1ZmZpeCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4ICYmIHJ1bGUubnVtYmVycy5sZW5ndGggPT09IDIgJiYgcnVsZS5udW1iZXJzWzBdID09PSAxKSB7XG4gICAgICByZXR1cm4gcmV0dXJuU3VmZml4KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucHJlcGVuZCAmJiBpZHgudG9TdHJpbmcoKSA/IHRoaXMub3B0aW9ucy5wcmVwZW5kICsgaWR4LnRvU3RyaW5nKCkgOiBpZHgudG9TdHJpbmcoKTtcbiAgfVxuICBzaG91bGRVc2VJbnRsQXBpKCkge1xuICAgIHJldHVybiAhbm9uSW50bFZlcnNpb25zLmluY2x1ZGVzKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTik7XG4gIH1cbn1cblxuY29uc3QgZGVlcEZpbmRXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoZGF0YSwgZGVmYXVsdERhdGEsIGtleSkge1xuICBsZXQga2V5U2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnLic7XG4gIGxldCBpZ25vcmVKU09OU3RydWN0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICBsZXQgcGF0aCA9IGdldFBhdGhXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSk7XG4gIGlmICghcGF0aCAmJiBpZ25vcmVKU09OU3RydWN0dXJlICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IGRlZXBGaW5kKGRhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gZGVlcEZpbmQoZGVmYXVsdERhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5jb25zdCByZWdleFNhZmUgPSB2YWwgPT4gdmFsLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuY2xhc3MgSW50ZXJwb2xhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ2ludGVycG9sYXRvcicpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCAodmFsdWUgPT4gdmFsdWUpO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJwb2xhdGlvbikgb3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgZXNjYXBlVmFsdWU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGVzY2FwZTogZXNjYXBlJDEsXG4gICAgICBlc2NhcGVWYWx1ZSxcbiAgICAgIHVzZVJhd1ZhbHVlVG9Fc2NhcGUsXG4gICAgICBwcmVmaXgsXG4gICAgICBwcmVmaXhFc2NhcGVkLFxuICAgICAgc3VmZml4LFxuICAgICAgc3VmZml4RXNjYXBlZCxcbiAgICAgIGZvcm1hdFNlcGFyYXRvcixcbiAgICAgIHVuZXNjYXBlU3VmZml4LFxuICAgICAgdW5lc2NhcGVQcmVmaXgsXG4gICAgICBuZXN0aW5nUHJlZml4LFxuICAgICAgbmVzdGluZ1ByZWZpeEVzY2FwZWQsXG4gICAgICBuZXN0aW5nU3VmZml4LFxuICAgICAgbmVzdGluZ1N1ZmZpeEVzY2FwZWQsXG4gICAgICBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvcixcbiAgICAgIG1heFJlcGxhY2VzLFxuICAgICAgYWx3YXlzRm9ybWF0XG4gICAgfSA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLmVzY2FwZSA9IGVzY2FwZSQxICE9PSB1bmRlZmluZWQgPyBlc2NhcGUkMSA6IGVzY2FwZTtcbiAgICB0aGlzLmVzY2FwZVZhbHVlID0gZXNjYXBlVmFsdWUgIT09IHVuZGVmaW5lZCA/IGVzY2FwZVZhbHVlIDogdHJ1ZTtcbiAgICB0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUgPSB1c2VSYXdWYWx1ZVRvRXNjYXBlICE9PSB1bmRlZmluZWQgPyB1c2VSYXdWYWx1ZVRvRXNjYXBlIDogZmFsc2U7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXggPyByZWdleEVzY2FwZShwcmVmaXgpIDogcHJlZml4RXNjYXBlZCB8fCAne3snO1xuICAgIHRoaXMuc3VmZml4ID0gc3VmZml4ID8gcmVnZXhFc2NhcGUoc3VmZml4KSA6IHN1ZmZpeEVzY2FwZWQgfHwgJ319JztcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IGZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy51bmVzY2FwZVByZWZpeCA9IHVuZXNjYXBlU3VmZml4ID8gJycgOiB1bmVzY2FwZVByZWZpeCB8fCAnLSc7XG4gICAgdGhpcy51bmVzY2FwZVN1ZmZpeCA9IHRoaXMudW5lc2NhcGVQcmVmaXggPyAnJyA6IHVuZXNjYXBlU3VmZml4IHx8ICcnO1xuICAgIHRoaXMubmVzdGluZ1ByZWZpeCA9IG5lc3RpbmdQcmVmaXggPyByZWdleEVzY2FwZShuZXN0aW5nUHJlZml4KSA6IG5lc3RpbmdQcmVmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCckdCgnKTtcbiAgICB0aGlzLm5lc3RpbmdTdWZmaXggPSBuZXN0aW5nU3VmZml4ID8gcmVnZXhFc2NhcGUobmVzdGluZ1N1ZmZpeCkgOiBuZXN0aW5nU3VmZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnKScpO1xuICAgIHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgPSBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy5tYXhSZXBsYWNlcyA9IG1heFJlcGxhY2VzIHx8IDEwMDA7XG4gICAgdGhpcy5hbHdheXNGb3JtYXQgPSBhbHdheXNGb3JtYXQgIT09IHVuZGVmaW5lZCA/IGFsd2F5c0Zvcm1hdCA6IGZhbHNlO1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zKSB0aGlzLmluaXQodGhpcy5vcHRpb25zKTtcbiAgfVxuICByZXNldFJlZ0V4cCgpIHtcbiAgICBjb25zdCBnZXRPclJlc2V0UmVnRXhwID0gKGV4aXN0aW5nUmVnRXhwLCBwYXR0ZXJuKSA9PiB7XG4gICAgICBpZiAoZXhpc3RpbmdSZWdFeHAgJiYgZXhpc3RpbmdSZWdFeHAuc291cmNlID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIGV4aXN0aW5nUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JlZ0V4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyk7XG4gICAgfTtcbiAgICB0aGlzLnJlZ2V4cCA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5yZWdleHAsIGAke3RoaXMucHJlZml4fSguKz8pJHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLnJlZ2V4cFVuZXNjYXBlID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLnJlZ2V4cFVuZXNjYXBlLCBgJHt0aGlzLnByZWZpeH0ke3RoaXMudW5lc2NhcGVQcmVmaXh9KC4rPykke3RoaXMudW5lc2NhcGVTdWZmaXh9JHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLm5lc3RpbmdSZWdleHAgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMubmVzdGluZ1JlZ2V4cCwgYCR7dGhpcy5uZXN0aW5nUHJlZml4fSguKz8pJHt0aGlzLm5lc3RpbmdTdWZmaXh9YCk7XG4gIH1cbiAgaW50ZXJwb2xhdGUoc3RyLCBkYXRhLCBsbmcsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCByZXBsYWNlcztcbiAgICBjb25zdCBkZWZhdWx0RGF0YSA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzIHx8IHt9O1xuICAgIGNvbnN0IGhhbmRsZUZvcm1hdCA9IGtleSA9PiB7XG4gICAgICBpZiAoa2V5LmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpIDwgMCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZGVlcEZpbmRXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSwgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciwgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hbHdheXNGb3JtYXQgPyB0aGlzLmZvcm1hdChwYXRoLCB1bmRlZmluZWQsIGxuZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrZXlcbiAgICAgICAgfSkgOiBwYXRoO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IGtleS5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcik7XG4gICAgICBjb25zdCBrID0gcC5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGYgPSBwLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpLnRyaW0oKTtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwgaywgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciwgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUpLCBmLCBsbmcsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbmtleToga1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0UmVnRXhwKCk7XG4gICAgY29uc3QgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyO1xuICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXM7XG4gICAgY29uc3QgdG9kb3MgPSBbe1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwVW5lc2NhcGUsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiByZWdleFNhZmUodmFsKVxuICAgIH0sIHtcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cCxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsKSkgOiByZWdleFNhZmUodmFsKVxuICAgIH1dO1xuICAgIHRvZG9zLmZvckVhY2godG9kbyA9PiB7XG4gICAgICByZXBsYWNlcyA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggPSB0b2RvLnJlZ2V4LmV4ZWMoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkVmFyID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaGVkVmFyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcihzdHIsIG1hdGNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlID0gdHlwZW9mIHRlbXAgPT09ICdzdHJpbmcnID8gdGVtcCA6ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgbWF0Y2hlZFZhcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgbWlzc2VkIHRvIHBhc3MgaW4gdmFyaWFibGUgJHttYXRjaGVkVmFyfSBmb3IgaW50ZXJwb2xhdGluZyAke3N0cn1gKTtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgIXRoaXMudXNlUmF3VmFsdWVUb0VzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gbWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FmZVZhbHVlID0gdG9kby5zYWZlVmFsdWUodmFsdWUpO1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgc2FmZVZhbHVlKTtcbiAgICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4ICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VzKys7XG4gICAgICAgIGlmIChyZXBsYWNlcyA+PSB0aGlzLm1heFJlcGxhY2VzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIG5lc3Qoc3RyLCBmYykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBjbG9uZWRPcHRpb25zO1xuICAgIGNvbnN0IGhhbmRsZUhhc09wdGlvbnMgPSAoa2V5LCBpbmhlcml0ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzZXAgPSB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yO1xuICAgICAgaWYgKGtleS5pbmRleE9mKHNlcCkgPCAwKSByZXR1cm4ga2V5O1xuICAgICAgY29uc3QgYyA9IGtleS5zcGxpdChuZXcgUmVnRXhwKGAke3NlcH1bIF0qe2ApKTtcbiAgICAgIGxldCBvcHRpb25zU3RyaW5nID0gYHske2NbMV19YDtcbiAgICAgIGtleSA9IGNbMF07XG4gICAgICBvcHRpb25zU3RyaW5nID0gdGhpcy5pbnRlcnBvbGF0ZShvcHRpb25zU3RyaW5nLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1hdGNoZWRTaW5nbGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC8nL2cpO1xuICAgICAgY29uc3QgbWF0Y2hlZERvdWJsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goL1wiL2cpO1xuICAgICAgaWYgKG1hdGNoZWRTaW5nbGVRdW90ZXMgJiYgbWF0Y2hlZFNpbmdsZVF1b3Rlcy5sZW5ndGggJSAyID09PSAwICYmICFtYXRjaGVkRG91YmxlUXVvdGVzIHx8IG1hdGNoZWREb3VibGVRdW90ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBvcHRpb25zU3RyaW5nID0gb3B0aW9uc1N0cmluZy5yZXBsYWNlKC8nL2csICdcIicpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xvbmVkT3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9uc1N0cmluZyk7XG4gICAgICAgIGlmIChpbmhlcml0ZWRPcHRpb25zKSBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAgIC4uLmluaGVyaXRlZE9wdGlvbnMsXG4gICAgICAgICAgLi4uY2xvbmVkT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBmYWlsZWQgcGFyc2luZyBvcHRpb25zIHN0cmluZyBpbiBuZXN0aW5nIGZvciBrZXkgJHtrZXl9YCwgZSk7XG4gICAgICAgIHJldHVybiBgJHtrZXl9JHtzZXB9JHtvcHRpb25zU3RyaW5nfWA7XG4gICAgICB9XG4gICAgICBpZiAoY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUgJiYgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWUuaW5kZXhPZih0aGlzLnByZWZpeCkgPiAtMSkgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2YgY2xvbmVkT3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJyA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgbGV0IGRvUmVkdWNlID0gZmFsc2U7XG4gICAgICBpZiAobWF0Y2hbMF0uaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgIT09IC0xICYmICEvey4qfS8udGVzdChtYXRjaFsxXSkpIHtcbiAgICAgICAgY29uc3QgciA9IG1hdGNoWzFdLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSk7XG4gICAgICAgIG1hdGNoWzFdID0gci5zaGlmdCgpO1xuICAgICAgICBmb3JtYXR0ZXJzID0gcjtcbiAgICAgICAgZG9SZWR1Y2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBmYyhoYW5kbGVIYXNPcHRpb25zLmNhbGwodGhpcywgbWF0Y2hbMV0udHJpbSgpLCBjbG9uZWRPcHRpb25zKSwgY2xvbmVkT3B0aW9ucyk7XG4gICAgICBpZiAodmFsdWUgJiYgbWF0Y2hbMF0gPT09IHN0ciAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgbWlzc2VkIHRvIHJlc29sdmUgJHttYXRjaFsxXX0gZm9yIG5lc3RpbmcgJHtzdHJ9YCk7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZWR1Y2UpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXJzLnJlZHVjZSgodiwgZikgPT4gdGhpcy5mb3JtYXQodiwgZiwgb3B0aW9ucy5sbmcsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IG1hdGNoWzFdLnRyaW0oKVxuICAgICAgICB9KSwgdmFsdWUudHJpbSgpKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCB2YWx1ZSk7XG4gICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmNvbnN0IHBhcnNlRm9ybWF0U3RyID0gZm9ybWF0U3RyID0+IHtcbiAgbGV0IGZvcm1hdE5hbWUgPSBmb3JtYXRTdHIudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIGNvbnN0IGZvcm1hdE9wdGlvbnMgPSB7fTtcbiAgaWYgKGZvcm1hdFN0ci5pbmRleE9mKCcoJykgPiAtMSkge1xuICAgIGNvbnN0IHAgPSBmb3JtYXRTdHIuc3BsaXQoJygnKTtcbiAgICBmb3JtYXROYW1lID0gcFswXS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBjb25zdCBvcHRTdHIgPSBwWzFdLnN1YnN0cmluZygwLCBwWzFdLmxlbmd0aCAtIDEpO1xuICAgIGlmIChmb3JtYXROYW1lID09PSAnY3VycmVuY3knICYmIG9wdFN0ci5pbmRleE9mKCc6JykgPCAwKSB7XG4gICAgICBpZiAoIWZvcm1hdE9wdGlvbnMuY3VycmVuY3kpIGZvcm1hdE9wdGlvbnMuY3VycmVuY3kgPSBvcHRTdHIudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0TmFtZSA9PT0gJ3JlbGF0aXZldGltZScgJiYgb3B0U3RyLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgIGlmICghZm9ybWF0T3B0aW9ucy5yYW5nZSkgZm9ybWF0T3B0aW9ucy5yYW5nZSA9IG9wdFN0ci50cmltKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBvcHRTdHIuc3BsaXQoJzsnKTtcbiAgICAgIG9wdHMuZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBvcHQuc3BsaXQoJzonKTtcbiAgICAgICAgICBjb25zdCB2YWwgPSByZXN0LmpvaW4oJzonKS50cmltKCkucmVwbGFjZSgvXicrfCcrJC9nLCAnJyk7XG4gICAgICAgICAgY29uc3QgdHJpbW1lZEtleSA9IGtleS50cmltKCk7XG4gICAgICAgICAgaWYgKCFmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gdmFsO1xuICAgICAgICAgIGlmICh2YWwgPT09ICdmYWxzZScpIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSBmYWxzZTtcbiAgICAgICAgICBpZiAodmFsID09PSAndHJ1ZScpIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSB0cnVlO1xuICAgICAgICAgIGlmICghaXNOYU4odmFsKSkgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXROYW1lLFxuICAgIGZvcm1hdE9wdGlvbnNcbiAgfTtcbn07XG5jb25zdCBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIgPSBmbiA9PiB7XG4gIGNvbnN0IGNhY2hlID0ge307XG4gIHJldHVybiAodmFsLCBsbmcsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgb3B0Rm9yQ2FjaGUgPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbmtleSAmJiBvcHRpb25zLmZvcm1hdFBhcmFtcyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtc1tvcHRpb25zLmludGVycG9sYXRpb25rZXldICYmIG9wdGlvbnNbb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSkge1xuICAgICAgb3B0Rm9yQ2FjaGUgPSB7XG4gICAgICAgIC4uLm9wdEZvckNhY2hlLFxuICAgICAgICBbb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBsbmcgKyBKU09OLnN0cmluZ2lmeShvcHRGb3JDYWNoZSk7XG4gICAgbGV0IGZvcm1hdHRlciA9IGNhY2hlW2tleV07XG4gICAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICAgIGZvcm1hdHRlciA9IGZuKGdldENsZWFuZWRDb2RlKGxuZyksIG9wdGlvbnMpO1xuICAgICAgY2FjaGVba2V5XSA9IGZvcm1hdHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlcih2YWwpO1xuICB9O1xufTtcbmNsYXNzIEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdmb3JtYXR0ZXInKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZm9ybWF0cyA9IHtcbiAgICAgIG51bWJlcjogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pLFxuICAgICAgY3VycmVuY3k6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIGRhdGV0aW1lOiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIHJlbGF0aXZldGltZTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsLCBvcHQucmFuZ2UgfHwgJ2RheScpO1xuICAgICAgfSksXG4gICAgICBsaXN0OiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH1cbiAgaW5pdChzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICAgIH07XG4gICAgY29uc3QgaU9wdHMgPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5mb3JtYXRTZXBhcmF0b3IgPSBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgPyBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgOiBpT3B0cy5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICB9XG4gIGFkZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGZjO1xuICB9XG4gIGFkZENhY2hlZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcihmYyk7XG4gIH1cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQsIGxuZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBpZiAoZm9ybWF0cy5sZW5ndGggPiAxICYmIGZvcm1hdHNbMF0uaW5kZXhPZignKCcpID4gMSAmJiBmb3JtYXRzWzBdLmluZGV4T2YoJyknKSA8IDAgJiYgZm9ybWF0cy5maW5kKGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcm1hdHMuZmluZEluZGV4KGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSk7XG4gICAgICBmb3JtYXRzWzBdID0gW2Zvcm1hdHNbMF0sIC4uLmZvcm1hdHMuc3BsaWNlKDEsIGxhc3RJbmRleCldLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtcyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtc1tvcHRpb25zLmludGVycG9sYXRpb25rZXldIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGwgPSB2YWxPcHRpb25zLmxvY2FsZSB8fCB2YWxPcHRpb25zLmxuZyB8fCBvcHRpb25zLmxvY2FsZSB8fCBvcHRpb25zLmxuZyB8fCBsbmc7XG4gICAgICAgICAgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKG1lbSwgbCwge1xuICAgICAgICAgICAgLi4uZm9ybWF0T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi52YWxPcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHRoZXJlIHdhcyBubyBmb3JtYXQgZnVuY3Rpb24gZm9yICR7Zm9ybWF0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW07XG4gICAgfSwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuY29uc3QgcmVtb3ZlUGVuZGluZyA9IChxLCBuYW1lKSA9PiB7XG4gIGlmIChxLnBlbmRpbmdbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBxLnBlbmRpbmdbbmFtZV07XG4gICAgcS5wZW5kaW5nQ291bnQtLTtcbiAgfVxufTtcbmNsYXNzIENvbm5lY3RvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGJhY2tlbmQsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBzZXJ2aWNlcy5sYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnYmFja2VuZENvbm5lY3RvcicpO1xuICAgIHRoaXMud2FpdGluZ1JlYWRzID0gW107XG4gICAgdGhpcy5tYXhQYXJhbGxlbFJlYWRzID0gb3B0aW9ucy5tYXhQYXJhbGxlbFJlYWRzIHx8IDEwO1xuICAgIHRoaXMucmVhZGluZ0NhbGxzID0gMDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPj0gMCA/IG9wdGlvbnMubWF4UmV0cmllcyA6IDU7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCA+PSAxID8gb3B0aW9ucy5yZXRyeVRpbWVvdXQgOiAzNTA7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICBpZiAodGhpcy5iYWNrZW5kICYmIHRoaXMuYmFja2VuZC5pbml0KSB7XG4gICAgICB0aGlzLmJhY2tlbmQuaW5pdChzZXJ2aWNlcywgb3B0aW9ucy5iYWNrZW5kLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcXVldWVMb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0b0xvYWQgPSB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0ge307XG4gICAgY29uc3QgdG9Mb2FkTGFuZ3VhZ2VzID0ge307XG4gICAgY29uc3QgdG9Mb2FkTmFtZXNwYWNlcyA9IHt9O1xuICAgIGxhbmd1YWdlcy5mb3JFYWNoKGxuZyA9PiB7XG4gICAgICBsZXQgaGFzQWxsTmFtZXNwYWNlcyA9IHRydWU7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7bG5nfXwke25zfWA7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxvYWQgJiYgdGhpcy5zdG9yZS5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPCAwKSA7IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMTtcbiAgICAgICAgICBoYXNBbGxOYW1lc3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWROYW1lc3BhY2VzW25zXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWROYW1lc3BhY2VzW25zXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFoYXNBbGxOYW1lc3BhY2VzKSB0b0xvYWRMYW5ndWFnZXNbbG5nXSA9IHRydWU7XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRvTG9hZCkubGVuZ3RoIHx8IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHtcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgcGVuZGluZ0NvdW50OiBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgsXG4gICAgICAgIGxvYWRlZDoge30sXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvTG9hZDogT2JqZWN0LmtleXModG9Mb2FkKSxcbiAgICAgIHBlbmRpbmc6IE9iamVjdC5rZXlzKHBlbmRpbmcpLFxuICAgICAgdG9Mb2FkTGFuZ3VhZ2VzOiBPYmplY3Qua2V5cyh0b0xvYWRMYW5ndWFnZXMpLFxuICAgICAgdG9Mb2FkTmFtZXNwYWNlczogT2JqZWN0LmtleXModG9Mb2FkTmFtZXNwYWNlcylcbiAgICB9O1xuICB9XG4gIGxvYWRlZChuYW1lLCBlcnIsIGRhdGEpIHtcbiAgICBjb25zdCBzID0gbmFtZS5zcGxpdCgnfCcpO1xuICAgIGNvbnN0IGxuZyA9IHNbMF07XG4gICAgY29uc3QgbnMgPSBzWzFdO1xuICAgIGlmIChlcnIpIHRoaXMuZW1pdCgnZmFpbGVkTG9hZGluZycsIGxuZywgbnMsIGVycik7XG4gICAgaWYgKCFlcnIgJiYgZGF0YSkge1xuICAgICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICBza2lwQ29weTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVbbmFtZV0gPSBlcnIgPyAtMSA6IDI7XG4gICAgaWYgKGVyciAmJiBkYXRhKSB0aGlzLnN0YXRlW25hbWVdID0gMDtcbiAgICBjb25zdCBsb2FkZWQgPSB7fTtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2gocSA9PiB7XG4gICAgICBwdXNoUGF0aChxLmxvYWRlZCwgW2xuZ10sIG5zKTtcbiAgICAgIHJlbW92ZVBlbmRpbmcocSwgbmFtZSk7XG4gICAgICBpZiAoZXJyKSBxLmVycm9ycy5wdXNoKGVycik7XG4gICAgICBpZiAocS5wZW5kaW5nQ291bnQgPT09IDAgJiYgIXEuZG9uZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhxLmxvYWRlZCkuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZFtsXSkgbG9hZGVkW2xdID0ge307XG4gICAgICAgICAgY29uc3QgbG9hZGVkS2V5cyA9IHEubG9hZGVkW2xdO1xuICAgICAgICAgIGlmIChsb2FkZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9hZGVkS2V5cy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICBpZiAobG9hZGVkW2xdW25dID09PSB1bmRlZmluZWQpIGxvYWRlZFtsXVtuXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxLmRvbmUgPSB0cnVlO1xuICAgICAgICBpZiAocS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcS5jYWxsYmFjayhxLmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcS5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdsb2FkZWQnLCBsb2FkZWQpO1xuICAgIHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcihxID0+ICFxLmRvbmUpO1xuICB9XG4gIHJlYWQobG5nLCBucywgZmNOYW1lKSB7XG4gICAgbGV0IHRyaWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGxldCB3YWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0aGlzLnJldHJ5VGltZW91dDtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWxuZy5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7XG4gICAgaWYgKHRoaXMucmVhZGluZ0NhbGxzID49IHRoaXMubWF4UGFyYWxsZWxSZWFkcykge1xuICAgICAgdGhpcy53YWl0aW5nUmVhZHMucHVzaCh7XG4gICAgICAgIGxuZyxcbiAgICAgICAgbnMsXG4gICAgICAgIGZjTmFtZSxcbiAgICAgICAgdHJpZWQsXG4gICAgICAgIHdhaXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMrKztcbiAgICBjb25zdCByZXNvbHZlciA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgIHRoaXMucmVhZGluZ0NhbGxzLS07XG4gICAgICBpZiAodGhpcy53YWl0aW5nUmVhZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy53YWl0aW5nUmVhZHMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5yZWFkKG5leHQubG5nLCBuZXh0Lm5zLCBuZXh0LmZjTmFtZSwgbmV4dC50cmllZCwgbmV4dC53YWl0LCBuZXh0LmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgJiYgZGF0YSAmJiB0cmllZCA8IHRoaXMubWF4UmV0cmllcykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlYWQuY2FsbCh0aGlzLCBsbmcsIG5zLCBmY05hbWUsIHRyaWVkICsgMSwgd2FpdCAqIDIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBmYyA9IHRoaXMuYmFja2VuZFtmY05hbWVdLmJpbmQodGhpcy5iYWNrZW5kKTtcbiAgICBpZiAoZmMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gZmMobG5nLCBucyk7XG4gICAgICAgIGlmIChyICYmIHR5cGVvZiByLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByLnRoZW4oZGF0YSA9PiByZXNvbHZlcihudWxsLCBkYXRhKSkuY2F0Y2gocmVzb2x2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVyKG51bGwsIHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZXIoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZjKGxuZywgbnMsIHJlc29sdmVyKTtcbiAgfVxuICBwcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZXMgPT09ICdzdHJpbmcnKSBsYW5ndWFnZXMgPSB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxhbmd1YWdlcyk7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJykgbmFtZXNwYWNlcyA9IFtuYW1lc3BhY2VzXTtcbiAgICBjb25zdCB0b0xvYWQgPSB0aGlzLnF1ZXVlTG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBpZiAoIXRvTG9hZC50b0xvYWQubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRvTG9hZC5wZW5kaW5nLmxlbmd0aCkgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0xvYWQudG9Mb2FkLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLmxvYWRPbmUobmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHt9LCBjYWxsYmFjayk7XG4gIH1cbiAgcmVsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcywge1xuICAgICAgcmVsb2FkOiB0cnVlXG4gICAgfSwgY2FsbGJhY2spO1xuICB9XG4gIGxvYWRPbmUobmFtZSkge1xuICAgIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIGNvbnN0IHMgPSBuYW1lLnNwbGl0KCd8Jyk7XG4gICAgY29uc3QgbG5nID0gc1swXTtcbiAgICBjb25zdCBucyA9IHNbMV07XG4gICAgdGhpcy5yZWFkKGxuZywgbnMsICdyZWFkJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpIHRoaXMubG9nZ2VyLndhcm4oYCR7cHJlZml4fWxvYWRpbmcgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ30gZmFpbGVkYCwgZXJyKTtcbiAgICAgIGlmICghZXJyICYmIGRhdGEpIHRoaXMubG9nZ2VyLmxvZyhgJHtwcmVmaXh9bG9hZGVkIG5hbWVzcGFjZSAke25zfSBmb3IgbGFuZ3VhZ2UgJHtsbmd9YCwgZGF0YSk7XG4gICAgICB0aGlzLmxvYWRlZChuYW1lLCBlcnIsIGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIHNhdmVNaXNzaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIGlzVXBkYXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIGxldCBjbGIgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6ICgpID0+IHt9O1xuICAgIGlmICh0aGlzLnNlcnZpY2VzLnV0aWxzICYmIHRoaXMuc2VydmljZXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnNlcnZpY2VzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZShuYW1lc3BhY2UpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBkaWQgbm90IHNhdmUga2V5IFwiJHtrZXl9XCIgYXMgdGhlIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCB8fCBrZXkgPT09ICcnKSByZXR1cm47XG4gICAgaWYgKHRoaXMuYmFja2VuZCAmJiB0aGlzLmJhY2tlbmQuY3JlYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc1VwZGF0ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kLmNyZWF0ZS5iaW5kKHRoaXMuYmFja2VuZCk7XG4gICAgICBpZiAoZmMubGVuZ3RoIDwgNikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByO1xuICAgICAgICAgIGlmIChmYy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBvcHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociAmJiB0eXBlb2Ygci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByLnRoZW4oZGF0YSA9PiBjbGIobnVsbCwgZGF0YSkpLmNhdGNoKGNsYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYihudWxsLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNsYihlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBjbGIsIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoKSA9PiAoe1xuICBkZWJ1ZzogZmFsc2UsXG4gIGluaXRJbW1lZGlhdGU6IHRydWUsXG4gIG5zOiBbJ3RyYW5zbGF0aW9uJ10sXG4gIGRlZmF1bHROUzogWyd0cmFuc2xhdGlvbiddLFxuICBmYWxsYmFja0xuZzogWydkZXYnXSxcbiAgZmFsbGJhY2tOUzogZmFsc2UsXG4gIHN1cHBvcnRlZExuZ3M6IGZhbHNlLFxuICBub25FeHBsaWNpdFN1cHBvcnRlZExuZ3M6IGZhbHNlLFxuICBsb2FkOiAnYWxsJyxcbiAgcHJlbG9hZDogZmFsc2UsXG4gIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0cnVlLFxuICBrZXlTZXBhcmF0b3I6ICcuJyxcbiAgbnNTZXBhcmF0b3I6ICc6JyxcbiAgcGx1cmFsU2VwYXJhdG9yOiAnXycsXG4gIGNvbnRleHRTZXBhcmF0b3I6ICdfJyxcbiAgcGFydGlhbEJ1bmRsZWRMYW5ndWFnZXM6IGZhbHNlLFxuICBzYXZlTWlzc2luZzogZmFsc2UsXG4gIHVwZGF0ZU1pc3Npbmc6IGZhbHNlLFxuICBzYXZlTWlzc2luZ1RvOiAnZmFsbGJhY2snLFxuICBzYXZlTWlzc2luZ1BsdXJhbHM6IHRydWUsXG4gIG1pc3NpbmdLZXlIYW5kbGVyOiBmYWxzZSxcbiAgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyOiBmYWxzZSxcbiAgcG9zdFByb2Nlc3M6IGZhbHNlLFxuICBwb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZDogZmFsc2UsXG4gIHJldHVybk51bGw6IGZhbHNlLFxuICByZXR1cm5FbXB0eVN0cmluZzogdHJ1ZSxcbiAgcmV0dXJuT2JqZWN0czogZmFsc2UsXG4gIGpvaW5BcnJheXM6IGZhbHNlLFxuICByZXR1cm5lZE9iamVjdEhhbmRsZXI6IGZhbHNlLFxuICBwYXJzZU1pc3NpbmdLZXlIYW5kbGVyOiBmYWxzZSxcbiAgYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5OiBmYWxzZSxcbiAgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGU6IGZhbHNlLFxuICBvdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcjogYXJncyA9PiB7XG4gICAgbGV0IHJldCA9IHt9O1xuICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcpIHJldCA9IGFyZ3NbMV07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJykgcmV0LmRlZmF1bHRWYWx1ZSA9IGFyZ3NbMV07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnc3RyaW5nJykgcmV0LnREZXNjcmlwdGlvbiA9IGFyZ3NbMl07XG4gICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYXJnc1szXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzNdIHx8IGFyZ3NbMl07XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHJldFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGludGVycG9sYXRpb246IHtcbiAgICBlc2NhcGVWYWx1ZTogdHJ1ZSxcbiAgICBmb3JtYXQ6IHZhbHVlID0+IHZhbHVlLFxuICAgIHByZWZpeDogJ3t7JyxcbiAgICBzdWZmaXg6ICd9fScsXG4gICAgZm9ybWF0U2VwYXJhdG9yOiAnLCcsXG4gICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcbiAgICBuZXN0aW5nUHJlZml4OiAnJHQoJyxcbiAgICBuZXN0aW5nU3VmZml4OiAnKScsXG4gICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3I6ICcsJyxcbiAgICBtYXhSZXBsYWNlczogMTAwMCxcbiAgICBza2lwT25WYXJpYWJsZXM6IHRydWVcbiAgfVxufSk7XG5jb25zdCB0cmFuc2Zvcm1PcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMubnMgPSBbb3B0aW9ucy5uc107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja0xuZyA9PT0gJ3N0cmluZycpIG9wdGlvbnMuZmFsbGJhY2tMbmcgPSBbb3B0aW9ucy5mYWxsYmFja0xuZ107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja05TID09PSAnc3RyaW5nJykgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG4gIGlmIChvcHRpb25zLnN1cHBvcnRlZExuZ3MgJiYgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmluZGV4T2YoJ2NpbW9kZScpIDwgMCkge1xuICAgIG9wdGlvbnMuc3VwcG9ydGVkTG5ncyA9IG9wdGlvbnMuc3VwcG9ydGVkTG5ncy5jb25jYXQoWydjaW1vZGUnXSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBiaW5kTWVtYmVyRnVuY3Rpb25zID0gaW5zdCA9PiB7XG4gIGNvbnN0IG1lbXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdCkpO1xuICBtZW1zLmZvckVhY2gobWVtID0+IHtcbiAgICBpZiAodHlwZW9mIGluc3RbbWVtXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5zdFttZW1dID0gaW5zdFttZW1dLmJpbmQoaW5zdCk7XG4gICAgfVxuICB9KTtcbn07XG5jbGFzcyBJMThuIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNlcnZpY2VzID0ge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgIHRoaXMubW9kdWxlcyA9IHtcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgYmluZE1lbWJlckZ1bmN0aW9ucyh0aGlzKTtcbiAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMuaXNJbml0aWFsaXplZCAmJiAhb3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbml0SW1tZWRpYXRlKSB7XG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmRlZmF1bHROUyAmJiBvcHRpb25zLmRlZmF1bHROUyAhPT0gZmFsc2UgJiYgb3B0aW9ucy5ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm5zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnM7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnMuaW5kZXhPZigndHJhbnNsYXRpb24nKSA8IDApIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0TlMgPSBvcHRpb25zLm5zWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWZPcHRzID0gZ2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4uZGVmT3B0cyxcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLnRyYW5zZm9ybU9wdGlvbnMob3B0aW9ucylcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSAhPT0gJ3YxJykge1xuICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgICAgIC4uLmRlZk9wdHMuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXNlckRlZmluZWRLZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubnNTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIH1cbiAgICBjb25zdCBjcmVhdGVDbGFzc09uRGVtYW5kID0gQ2xhc3NPck9iamVjdCA9PiB7XG4gICAgICBpZiAoIUNsYXNzT3JPYmplY3QpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBDbGFzc09yT2JqZWN0ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IENsYXNzT3JPYmplY3QoKTtcbiAgICAgIHJldHVybiBDbGFzc09yT2JqZWN0O1xuICAgIH07XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkge1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sb2dnZXIpIHtcbiAgICAgICAgYmFzZUxvZ2dlci5pbml0KGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxvZ2dlciksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQobnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXR0ZXI7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLm1vZHVsZXMuZm9ybWF0dGVyO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgSW50bCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gRm9ybWF0dGVyO1xuICAgICAgfVxuICAgICAgY29uc3QgbHUgPSBuZXcgTGFuZ3VhZ2VVdGlsKHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUodGhpcy5vcHRpb25zLnJlc291cmNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNlcnZpY2VzO1xuICAgICAgcy5sb2dnZXIgPSBiYXNlTG9nZ2VyO1xuICAgICAgcy5yZXNvdXJjZVN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgIHMubGFuZ3VhZ2VVdGlscyA9IGx1O1xuICAgICAgcy5wbHVyYWxSZXNvbHZlciA9IG5ldyBQbHVyYWxSZXNvbHZlcihsdSwge1xuICAgICAgICBwcmVwZW5kOiB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yLFxuICAgICAgICBjb21wYXRpYmlsaXR5SlNPTjogdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OLFxuICAgICAgICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4XG4gICAgICB9KTtcbiAgICAgIGlmIChmb3JtYXR0ZXIgJiYgKCF0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgfHwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID09PSBkZWZPcHRzLmludGVycG9sYXRpb24uZm9ybWF0KSkge1xuICAgICAgICBzLmZvcm1hdHRlciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQoZm9ybWF0dGVyKTtcbiAgICAgICAgcy5mb3JtYXR0ZXIuaW5pdChzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPSBzLmZvcm1hdHRlci5mb3JtYXQuYmluZChzLmZvcm1hdHRlcik7XG4gICAgICB9XG4gICAgICBzLmludGVycG9sYXRvciA9IG5ldyBJbnRlcnBvbGF0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgIHMudXRpbHMgPSB7XG4gICAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogdGhpcy5oYXNMb2FkZWROYW1lc3BhY2UuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3IoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHMuYmFja2VuZENvbm5lY3Rvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcikge1xuICAgICAgICBzLmxhbmd1YWdlRGV0ZWN0b3IgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKTtcbiAgICAgICAgaWYgKHMubGFuZ3VhZ2VEZXRlY3Rvci5pbml0KSBzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdChzLCB0aGlzLm9wdGlvbnMuZGV0ZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KSB7XG4gICAgICAgIHMuaTE4bkZvcm1hdCA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQpO1xuICAgICAgICBpZiAocy5pMThuRm9ybWF0LmluaXQpIHMuaTE4bkZvcm1hdC5pbml0KHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IodGhpcy5zZXJ2aWNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMudHJhbnNsYXRvci5vbignKicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICBpZiAobS5pbml0KSBtLmluaXQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQ7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgY29uc3QgY29kZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0RmFsbGJhY2tDb2Rlcyh0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgaWYgKGNvZGVzLmxlbmd0aCA+IDAgJiYgY29kZXNbMF0gIT09ICdkZXYnKSB0aGlzLm9wdGlvbnMubG5nID0gY29kZXNbMF07XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBubyBsYW5ndWFnZURldGVjdG9yIGlzIHVzZWQgYW5kIG5vIGxuZyBpcyBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlQXBpID0gWydnZXRSZXNvdXJjZScsICdoYXNSZXNvdXJjZUJ1bmRsZScsICdnZXRSZXNvdXJjZUJ1bmRsZScsICdnZXREYXRhQnlMYW5ndWFnZSddO1xuICAgIHN0b3JlQXBpLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcmVBcGlDaGFpbmVkID0gWydhZGRSZXNvdXJjZScsICdhZGRSZXNvdXJjZXMnLCAnYWRkUmVzb3VyY2VCdW5kbGUnLCAncmVtb3ZlUmVzb3VyY2VCdW5kbGUnXTtcbiAgICBzdG9yZUFwaUNoYWluZWQuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaW5pc2ggPSAoZXJyLCB0KSA9PiB7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCAmJiAhdGhpcy5pbml0aWFsaXplZFN0b3JlT25jZSkgdGhpcy5sb2dnZXIud2FybignaW5pdDogaTE4bmV4dCBpcyBhbHJlYWR5IGluaXRpYWxpemVkLiBZb3Ugc2hvdWxkIGNhbGwgaW5pdCBqdXN0IG9uY2UhJyk7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzQ2xvbmUpIHRoaXMubG9nZ2VyLmxvZygnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0KTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB0KTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sYW5ndWFnZXMgJiYgdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScgJiYgIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIGZpbmlzaChudWxsLCB0aGlzLnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNoYW5nZUxhbmd1YWdlKHRoaXMub3B0aW9ucy5sbmcsIGZpbmlzaCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc291cmNlcyB8fCAhdGhpcy5vcHRpb25zLmluaXRJbW1lZGlhdGUpIHtcbiAgICAgIGxvYWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChsb2FkLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGxvYWRSZXNvdXJjZXMobGFuZ3VhZ2UpIHtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gICAgbGV0IHVzZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGNvbnN0IHVzZWRMbmcgPSB0eXBlb2YgbGFuZ3VhZ2UgPT09ICdzdHJpbmcnID8gbGFuZ3VhZ2UgOiB0aGlzLmxhbmd1YWdlO1xuICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2UgPT09ICdmdW5jdGlvbicpIHVzZWRDYWxsYmFjayA9IGxhbmd1YWdlO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnJlc291cmNlcyB8fCB0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHtcbiAgICAgIGlmICh1c2VkTG5nICYmIHVzZWRMbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScgJiYgKCF0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCB0aGlzLm9wdGlvbnMucHJlbG9hZC5sZW5ndGggPT09IDApKSByZXR1cm4gdXNlZENhbGxiYWNrKCk7XG4gICAgICBjb25zdCB0b0xvYWQgPSBbXTtcbiAgICAgIGNvbnN0IGFwcGVuZCA9IGxuZyA9PiB7XG4gICAgICAgIGlmICghbG5nKSByZXR1cm47XG4gICAgICAgIGlmIChsbmcgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxuZyk7XG4gICAgICAgIGxuZ3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAobCA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgICBpZiAodG9Mb2FkLmluZGV4T2YobCkgPCAwKSB0b0xvYWQucHVzaChsKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKCF1c2VkTG5nKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICAgIGZhbGxiYWNrcy5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCh1c2VkTG5nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJlbG9hZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucHJlbG9hZC5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5sb2FkKHRvTG9hZCwgdGhpcy5vcHRpb25zLm5zLCBlID0+IHtcbiAgICAgICAgaWYgKCFlICYmICF0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgJiYgdGhpcy5sYW5ndWFnZSkgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICB1c2VkQ2FsbGJhY2soZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXNlZENhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxuICByZWxvYWRSZXNvdXJjZXMobG5ncywgbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGlmICh0eXBlb2YgbG5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBsbmdzO1xuICAgICAgbG5ncyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBucztcbiAgICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWxuZ3MpIGxuZ3MgPSB0aGlzLmxhbmd1YWdlcztcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5ucztcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnJlbG9hZChsbmdzLCBucywgZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIHVzZShtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYW4gdW5kZWZpbmVkIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAoIW1vZHVsZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhIHdyb25nIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdiYWNrZW5kJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmJhY2tlbmQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xvZ2dlcicgfHwgbW9kdWxlLmxvZyAmJiBtb2R1bGUud2FybiAmJiBtb2R1bGUuZXJyb3IpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sb2dnZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xhbmd1YWdlRGV0ZWN0b3InKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3RvciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnaTE4bkZvcm1hdCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5pMThuRm9ybWF0ID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdwb3N0UHJvY2Vzc29yJykge1xuICAgICAgcG9zdFByb2Nlc3Nvci5hZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSk7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2Zvcm1hdHRlcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJzNyZFBhcnR5Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLnB1c2gobW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UmVzb2x2ZWRMYW5ndWFnZShsKSB7XG4gICAgaWYgKCFsIHx8ICF0aGlzLmxhbmd1YWdlcykgcmV0dXJuO1xuICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGwpID4gLTEpIHJldHVybjtcbiAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgdGhpcy5sYW5ndWFnZXMubGVuZ3RoOyBsaSsrKSB7XG4gICAgICBjb25zdCBsbmdJbkxuZ3MgPSB0aGlzLmxhbmd1YWdlc1tsaV07XG4gICAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsbmdJbkxuZ3MpID4gLTEpIGNvbnRpbnVlO1xuICAgICAgaWYgKHRoaXMuc3RvcmUuaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zKGxuZ0luTG5ncykpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbG5nSW5MbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSBsbmc7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2luZycsIGxuZyk7XG4gICAgY29uc3Qgc2V0TG5nUHJvcHMgPSBsID0+IHtcbiAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsO1xuICAgICAgdGhpcy5sYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGwpO1xuICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKGwpO1xuICAgIH07XG4gICAgY29uc3QgZG9uZSA9IChlcnIsIGwpID0+IHtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudCguLi5hcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnQoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0TG5nID0gbG5ncyA9PiB7XG4gICAgICBpZiAoIWxuZyAmJiAhbG5ncyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IpIGxuZ3MgPSBbXTtcbiAgICAgIGNvbnN0IGwgPSB0eXBlb2YgbG5ncyA9PT0gJ3N0cmluZycgPyBsbmdzIDogdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEJlc3RNYXRjaEZyb21Db2RlcyhsbmdzKTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdG9yLmxhbmd1YWdlKSB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmNhY2hlVXNlckxhbmd1YWdlKSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuY2FjaGVVc2VyTGFuZ3VhZ2UobCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRSZXNvdXJjZXMobCwgZXJyID0+IHtcbiAgICAgICAgZG9uZShlcnIsIGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgc2V0TG5nKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKSk7XG4gICAgfSBlbHNlIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkudGhlbihzZXRMbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdChzZXRMbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMbmcobG5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGdldEZpeGVkVChsbmcsIG5zLCBrZXlQcmVmaXgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICBjb25zdCBmaXhlZFQgPSBmdW5jdGlvbiAoa2V5LCBvcHRzKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4zID4gMiA/IF9sZW4zIC0gMiA6IDApLCBfa2V5MyA9IDI7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICByZXN0W19rZXkzIC0gMl0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBfdGhpczMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihba2V5LCBvcHRzXS5jb25jYXQocmVzdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxuZyA9IG9wdGlvbnMubG5nIHx8IGZpeGVkVC5sbmc7XG4gICAgICBvcHRpb25zLmxuZ3MgPSBvcHRpb25zLmxuZ3MgfHwgZml4ZWRULmxuZ3M7XG4gICAgICBvcHRpb25zLm5zID0gb3B0aW9ucy5ucyB8fCBmaXhlZFQubnM7XG4gICAgICBpZiAob3B0aW9ucy5rZXlQcmVmaXggIT09ICcnKSBvcHRpb25zLmtleVByZWZpeCA9IG9wdGlvbnMua2V5UHJlZml4IHx8IGtleVByZWZpeCB8fCBmaXhlZFQua2V5UHJlZml4O1xuICAgICAgY29uc3Qga2V5U2VwYXJhdG9yID0gX3RoaXMzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcbiAgICAgIGxldCByZXN1bHRLZXk7XG4gICAgICBpZiAob3B0aW9ucy5rZXlQcmVmaXggJiYgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgIHJlc3VsdEtleSA9IGtleS5tYXAoayA9PiBgJHtvcHRpb25zLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2t9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRLZXkgPSBvcHRpb25zLmtleVByZWZpeCA/IGAke29wdGlvbnMua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMzLnQocmVzdWx0S2V5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgbG5nID09PSAnc3RyaW5nJykge1xuICAgICAgZml4ZWRULmxuZyA9IGxuZztcbiAgICB9IGVsc2Uge1xuICAgICAgZml4ZWRULmxuZ3MgPSBsbmc7XG4gICAgfVxuICAgIGZpeGVkVC5ucyA9IG5zO1xuICAgIGZpeGVkVC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgcmV0dXJuIGZpeGVkVDtcbiAgfVxuICB0KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0b3IgJiYgdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZSguLi5hcmd1bWVudHMpO1xuICB9XG4gIGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICYmIHRoaXMudHJhbnNsYXRvci5leGlzdHMoLi4uYXJndW1lbnRzKTtcbiAgfVxuICBzZXREZWZhdWx0TmFtZXNwYWNlKG5zKSB7XG4gICAgdGhpcy5vcHRpb25zLmRlZmF1bHROUyA9IG5zO1xuICB9XG4gIGhhc0xvYWRlZE5hbWVzcGFjZShucykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuZXh0IHdhcyBub3QgaW5pdGlhbGl6ZWQnLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5sYW5ndWFnZXMgfHwgIXRoaXMubGFuZ3VhZ2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaGFzTG9hZGVkTmFtZXNwYWNlOiBpMThuLmxhbmd1YWdlcyB3ZXJlIHVuZGVmaW5lZCBvciBlbXB0eScsIHRoaXMubGFuZ3VhZ2VzKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG5nID0gb3B0aW9ucy5sbmcgfHwgdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8IHRoaXMubGFuZ3VhZ2VzWzBdO1xuICAgIGNvbnN0IGZhbGxiYWNrTG5nID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIDogZmFsc2U7XG4gICAgY29uc3QgbGFzdExuZyA9IHRoaXMubGFuZ3VhZ2VzW3RoaXMubGFuZ3VhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGxvYWROb3RQZW5kaW5nID0gKGwsIG4pID0+IHtcbiAgICAgIGNvbnN0IGxvYWRTdGF0ZSA9IHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5zdGF0ZVtgJHtsfXwke259YF07XG4gICAgICByZXR1cm4gbG9hZFN0YXRlID09PSAtMSB8fCBsb2FkU3RhdGUgPT09IDAgfHwgbG9hZFN0YXRlID09PSAyO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMucHJlY2hlY2spIHtcbiAgICAgIGNvbnN0IHByZVJlc3VsdCA9IG9wdGlvbnMucHJlY2hlY2sodGhpcywgbG9hZE5vdFBlbmRpbmcpO1xuICAgICAgaWYgKHByZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcHJlUmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IuYmFja2VuZCB8fCB0aGlzLm9wdGlvbnMucmVzb3VyY2VzICYmICF0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChsb2FkTm90UGVuZGluZyhsbmcsIG5zKSAmJiAoIWZhbGxiYWNrTG5nIHx8IGxvYWROb3RQZW5kaW5nKGxhc3RMbmcsIG5zKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2FkTmFtZXNwYWNlcyhucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubnMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBucyA9PT0gJ3N0cmluZycpIG5zID0gW25zXTtcbiAgICBucy5mb3JFYWNoKG4gPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG4pIDwgMCkgdGhpcy5vcHRpb25zLm5zLnB1c2gobik7XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGxvYWRMYW5ndWFnZXMobG5ncywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnc3RyaW5nJykgbG5ncyA9IFtsbmdzXTtcbiAgICBjb25zdCBwcmVsb2FkZWQgPSB0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCBbXTtcbiAgICBjb25zdCBuZXdMbmdzID0gbG5ncy5maWx0ZXIobG5nID0+IHByZWxvYWRlZC5pbmRleE9mKGxuZykgPCAwICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5pc1N1cHBvcnRlZENvZGUobG5nKSk7XG4gICAgaWYgKCFuZXdMbmdzLmxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMucHJlbG9hZCA9IHByZWxvYWRlZC5jb25jYXQobmV3TG5ncyk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGRpcihsbmcpIHtcbiAgICBpZiAoIWxuZykgbG5nID0gdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8ICh0aGlzLmxhbmd1YWdlcyAmJiB0aGlzLmxhbmd1YWdlcy5sZW5ndGggPiAwID8gdGhpcy5sYW5ndWFnZXNbMF0gOiB0aGlzLmxhbmd1YWdlKTtcbiAgICBpZiAoIWxuZykgcmV0dXJuICdydGwnO1xuICAgIGNvbnN0IHJ0bExuZ3MgPSBbJ2FyJywgJ3NodScsICdzcXInLCAnc3NoJywgJ3hhYScsICd5aGQnLCAneXVkJywgJ2FhbycsICdhYmgnLCAnYWJ2JywgJ2FjbScsICdhY3EnLCAnYWN3JywgJ2FjeCcsICdhY3knLCAnYWRmJywgJ2FkcycsICdhZWInLCAnYWVjJywgJ2FmYicsICdhanAnLCAnYXBjJywgJ2FwZCcsICdhcmInLCAnYXJxJywgJ2FycycsICdhcnknLCAnYXJ6JywgJ2F1eicsICdhdmwnLCAnYXloJywgJ2F5bCcsICdheW4nLCAnYXlwJywgJ2JieicsICdwZ2EnLCAnaGUnLCAnaXcnLCAncHMnLCAncGJ0JywgJ3BidScsICdwc3QnLCAncHJwJywgJ3ByZCcsICd1ZycsICd1cicsICd5ZGQnLCAneWRzJywgJ3lpaCcsICdqaScsICd5aScsICdoYm8nLCAnbWVuJywgJ3htbicsICdmYScsICdqcHInLCAncGVvJywgJ3BlcycsICdwcnMnLCAnZHYnLCAnc2FtJywgJ2NrYiddO1xuICAgIGNvbnN0IGxhbmd1YWdlVXRpbHMgPSB0aGlzLnNlcnZpY2VzICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscyB8fCBuZXcgTGFuZ3VhZ2VVdGlsKGdldCgpKTtcbiAgICByZXR1cm4gcnRsTG5ncy5pbmRleE9mKGxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUobG5nKSkgPiAtMSB8fCBsbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCctYXJhYicpID4gMSA/ICdydGwnIDogJ2x0cic7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IEkxOG4ob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG4gIGNsb25lSW5zdGFuY2UoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgICBjb25zdCBmb3JrUmVzb3VyY2VTdG9yZSA9IG9wdGlvbnMuZm9ya1Jlc291cmNlU3RvcmU7XG4gICAgaWYgKGZvcmtSZXNvdXJjZVN0b3JlKSBkZWxldGUgb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC4uLntcbiAgICAgICAgaXNDbG9uZTogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgSTE4bihtZXJnZWRPcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLmxvZ2dlciA9IGNsb25lLmxvZ2dlci5jbG9uZShvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgbWVtYmVyc1RvQ29weSA9IFsnc3RvcmUnLCAnc2VydmljZXMnLCAnbGFuZ3VhZ2UnXTtcbiAgICBtZW1iZXJzVG9Db3B5LmZvckVhY2gobSA9PiB7XG4gICAgICBjbG9uZVttXSA9IHRoaXNbbV07XG4gICAgfSk7XG4gICAgY2xvbmUuc2VydmljZXMgPSB7XG4gICAgICAuLi50aGlzLnNlcnZpY2VzXG4gICAgfTtcbiAgICBjbG9uZS5zZXJ2aWNlcy51dGlscyA9IHtcbiAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogY2xvbmUuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQoY2xvbmUpXG4gICAgfTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIHtcbiAgICAgIGNsb25lLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUodGhpcy5zdG9yZS5kYXRhLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgIGNsb25lLnNlcnZpY2VzLnJlc291cmNlU3RvcmUgPSBjbG9uZS5zdG9yZTtcbiAgICB9XG4gICAgY2xvbmUudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKGNsb25lLnNlcnZpY2VzLCBtZXJnZWRPcHRpb25zKTtcbiAgICBjbG9uZS50cmFuc2xhdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgY2xvbmUuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgY2xvbmUuaW5pdChtZXJnZWRPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vcHRpb25zID0gbWVyZ2VkT3B0aW9ucztcbiAgICBjbG9uZS50cmFuc2xhdG9yLmJhY2tlbmRDb25uZWN0b3Iuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgIGxhbmd1YWdlczogdGhpcy5sYW5ndWFnZXMsXG4gICAgICByZXNvbHZlZExhbmd1YWdlOiB0aGlzLnJlc29sdmVkTGFuZ3VhZ2VcbiAgICB9O1xuICB9XG59XG5jb25zdCBpbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2UoKTtcbmluc3RhbmNlLmNyZWF0ZUluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2UgPSBpbnN0YW5jZS5jcmVhdGVJbnN0YW5jZTtcbmNvbnN0IGRpciA9IGluc3RhbmNlLmRpcjtcbmNvbnN0IGluaXQgPSBpbnN0YW5jZS5pbml0O1xuY29uc3QgbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLmxvYWRSZXNvdXJjZXM7XG5jb25zdCByZWxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5yZWxvYWRSZXNvdXJjZXM7XG5jb25zdCB1c2UgPSBpbnN0YW5jZS51c2U7XG5jb25zdCBjaGFuZ2VMYW5ndWFnZSA9IGluc3RhbmNlLmNoYW5nZUxhbmd1YWdlO1xuY29uc3QgZ2V0Rml4ZWRUID0gaW5zdGFuY2UuZ2V0Rml4ZWRUO1xuY29uc3QgdCA9IGluc3RhbmNlLnQ7XG5jb25zdCBleGlzdHMgPSBpbnN0YW5jZS5leGlzdHM7XG5jb25zdCBzZXREZWZhdWx0TmFtZXNwYWNlID0gaW5zdGFuY2Uuc2V0RGVmYXVsdE5hbWVzcGFjZTtcbmNvbnN0IGhhc0xvYWRlZE5hbWVzcGFjZSA9IGluc3RhbmNlLmhhc0xvYWRlZE5hbWVzcGFjZTtcbmNvbnN0IGxvYWROYW1lc3BhY2VzID0gaW5zdGFuY2UubG9hZE5hbWVzcGFjZXM7XG5jb25zdCBsb2FkTGFuZ3VhZ2VzID0gaW5zdGFuY2UubG9hZExhbmd1YWdlcztcblxuZXhwb3J0IHsgY2hhbmdlTGFuZ3VhZ2UsIGNyZWF0ZUluc3RhbmNlLCBpbnN0YW5jZSBhcyBkZWZhdWx0LCBkaXIsIGV4aXN0cywgZ2V0Rml4ZWRULCBoYXNMb2FkZWROYW1lc3BhY2UsIGluaXQsIGxvYWRMYW5ndWFnZXMsIGxvYWROYW1lc3BhY2VzLCBsb2FkUmVzb3VyY2VzLCByZWxvYWRSZXNvdXJjZXMsIHNldERlZmF1bHROYW1lc3BhY2UsIHQsIHVzZSB9O1xuIl0sIm5hbWVzIjpbImNvbnNvbGVMb2dnZXIiLCJ0eXBlIiwibG9nIiwiYXJncyIsIm91dHB1dCIsIndhcm4iLCJlcnJvciIsImNvbnNvbGUiLCJhcHBseSIsIkxvZ2dlciIsImluaXQiLCJjb25jcmV0ZUxvZ2dlciIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwcmVmaXgiLCJsb2dnZXIiLCJkZWJ1ZyIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJmb3J3YXJkIiwiX2xlbjIiLCJfa2V5MiIsIl9sZW4zIiwiX2tleTMiLCJkZXByZWNhdGUiLCJfbGVuNCIsIl9rZXk0IiwibHZsIiwiZGVidWdPbmx5IiwiY3JlYXRlIiwibW9kdWxlTmFtZSIsImNsb25lIiwiY29uc3RydWN0b3IiLCJiYXNlTG9nZ2VyIiwiRXZlbnRFbWl0dGVyIiwib24iLCJldmVudHMiLCJsaXN0ZW5lciIsInNwbGl0IiwiZm9yRWFjaCIsImV2ZW50Iiwib2JzZXJ2ZXJzIiwiTWFwIiwibnVtTGlzdGVuZXJzIiwiZ2V0Iiwic2V0Iiwib2ZmIiwiZGVsZXRlIiwiZW1pdCIsImNsb25lZCIsImZyb20iLCJlbnRyaWVzIiwiX3JlZiIsIm9ic2VydmVyIiwibnVtVGltZXNBZGRlZCIsImkiLCJfcmVmMiIsImRlZmVyIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFrZVN0cmluZyIsIm9iamVjdCIsImNvcHkiLCJhIiwicyIsInQiLCJtIiwibGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCIsImNsZWFuS2V5Iiwia2V5IiwiaW5kZXhPZiIsInJlcGxhY2UiLCJjYW5Ob3RUcmF2ZXJzZURlZXBlciIsImdldExhc3RPZlBhdGgiLCJwYXRoIiwiRW1wdHkiLCJzdGFjayIsInN0YWNrSW5kZXgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJvYmoiLCJrIiwic2V0UGF0aCIsIm5ld1ZhbHVlIiwiZSIsInAiLCJzbGljZSIsImxhc3QiLCJwdXNoUGF0aCIsImNvbmNhdCIsInB1c2giLCJnZXRQYXRoIiwiZ2V0UGF0aFdpdGhEZWZhdWx0cyIsImRhdGEiLCJkZWZhdWx0RGF0YSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsIm92ZXJ3cml0ZSIsInByb3AiLCJTdHJpbmciLCJyZWdleEVzY2FwZSIsInN0ciIsIl9lbnRpdHlNYXAiLCJlc2NhcGUiLCJSZWdFeHBDYWNoZSIsImdldFJlZ0V4cCIsInBhdHRlcm4iLCJyZWdFeHBGcm9tQ2FjaGUiLCJyZWdFeHBNYXAiLCJyZWdFeHBOZXciLCJSZWdFeHAiLCJyZWdFeHBRdWV1ZSIsImNhcGFjaXR5Iiwic2hpZnQiLCJjaGFycyIsImxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSIsImxvb2tzTGlrZU9iamVjdFBhdGgiLCJuc1NlcGFyYXRvciIsImtleVNlcGFyYXRvciIsInBvc3NpYmxlQ2hhcnMiLCJmaWx0ZXIiLCJjIiwiciIsIm1hcCIsImpvaW4iLCJtYXRjaGVkIiwidGVzdCIsImtpIiwic3Vic3RyaW5nIiwiZGVlcEZpbmQiLCJ0b2tlbnMiLCJjdXJyZW50IiwibmV4dCIsIm5leHRQYXRoIiwiaiIsImdldENsZWFuZWRDb2RlIiwiY29kZSIsIlJlc291cmNlU3RvcmUiLCJhZGROYW1lc3BhY2VzIiwibnMiLCJyZW1vdmVOYW1lc3BhY2VzIiwiaW5kZXgiLCJzcGxpY2UiLCJnZXRSZXNvdXJjZSIsImxuZyIsImlnbm9yZUpTT05TdHJ1Y3R1cmUiLCJpc0FycmF5IiwicmVzdWx0IiwiYWRkUmVzb3VyY2UiLCJzaWxlbnQiLCJhZGRSZXNvdXJjZXMiLCJyZXNvdXJjZXMiLCJhZGRSZXNvdXJjZUJ1bmRsZSIsImRlZXAiLCJza2lwQ29weSIsInBhY2siLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJyZW1vdmVSZXNvdXJjZUJ1bmRsZSIsImhhc1Jlc291cmNlQnVuZGxlIiwiZ2V0UmVzb3VyY2VCdW5kbGUiLCJkZWZhdWx0TlMiLCJjb21wYXRpYmlsaXR5QVBJIiwiZ2V0RGF0YUJ5TGFuZ3VhZ2UiLCJoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMiLCJuIiwia2V5cyIsImZpbmQiLCJ2IiwidG9KU09OIiwicG9zdFByb2Nlc3NvciIsInByb2Nlc3NvcnMiLCJhZGRQb3N0UHJvY2Vzc29yIiwibW9kdWxlIiwibmFtZSIsImhhbmRsZSIsInRyYW5zbGF0b3IiLCJwcm9jZXNzb3IiLCJwcm9jZXNzIiwiY2hlY2tlZExvYWRlZEZvciIsIlRyYW5zbGF0b3IiLCJjaGFuZ2VMYW5ndWFnZSIsImxhbmd1YWdlIiwiZXhpc3RzIiwiaW50ZXJwb2xhdGlvbiIsInJlc29sdmVkIiwiZXh0cmFjdEZyb21LZXkiLCJuYW1lc3BhY2VzIiwid291bGRDaGVja0Zvck5zSW5LZXkiLCJzZWVtc05hdHVyYWxMYW5ndWFnZSIsInVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yIiwidXNlckRlZmluZWROc1NlcGFyYXRvciIsIm1hdGNoIiwiaW50ZXJwb2xhdG9yIiwibmVzdGluZ1JlZ2V4cCIsInBhcnRzIiwidHJhbnNsYXRlIiwibGFzdEtleSIsIm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyIiwicmV0dXJuRGV0YWlscyIsIm5hbWVzcGFjZSIsImFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIiwidG9Mb3dlckNhc2UiLCJ1c2VkS2V5IiwiZXhhY3RVc2VkS2V5IiwidXNlZExuZyIsInVzZWROUyIsInVzZWRQYXJhbXMiLCJnZXRVc2VkUGFyYW1zRGV0YWlscyIsInJlc1VzZWRLZXkiLCJyZXNFeGFjdFVzZWRLZXkiLCJyZXNUeXBlIiwidG9TdHJpbmciLCJub09iamVjdCIsImpvaW5BcnJheXMiLCJoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCIsImkxOG5Gb3JtYXQiLCJoYW5kbGVBc09iamVjdCIsInJldHVybk9iamVjdHMiLCJyZXR1cm5lZE9iamVjdEhhbmRsZXIiLCJyZXNUeXBlSXNBcnJheSIsIm5ld0tleVRvVXNlIiwiZGVlcEtleSIsImV4dGVuZFRyYW5zbGF0aW9uIiwidXNlZERlZmF1bHQiLCJuZWVkc1BsdXJhbEhhbmRsaW5nIiwiY291bnQiLCJoYXNEZWZhdWx0VmFsdWUiLCJkZWZhdWx0VmFsdWVTdWZmaXgiLCJwbHVyYWxSZXNvbHZlciIsImdldFN1ZmZpeCIsImRlZmF1bHRWYWx1ZVN1ZmZpeE9yZGluYWxGYWxsYmFjayIsIm9yZGluYWwiLCJuZWVkc1plcm9TdWZmaXhMb29rdXAiLCJzaG91bGRVc2VJbnRsQXBpIiwiZGVmYXVsdFZhbHVlIiwicGx1cmFsU2VwYXJhdG9yIiwiaXNWYWxpZExvb2t1cCIsIm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSIsInJlc0Zvck1pc3NpbmciLCJ1cGRhdGVNaXNzaW5nIiwiZmsiLCJsbmdzIiwiZmFsbGJhY2tMbmdzIiwibGFuZ3VhZ2VVdGlscyIsImdldEZhbGxiYWNrQ29kZXMiLCJmYWxsYmFja0xuZyIsInNhdmVNaXNzaW5nVG8iLCJ0b1Jlc29sdmVIaWVyYXJjaHkiLCJzZW5kIiwibCIsInNwZWNpZmljRGVmYXVsdFZhbHVlIiwiZGVmYXVsdEZvck1pc3NpbmciLCJtaXNzaW5nS2V5SGFuZGxlciIsImJhY2tlbmRDb25uZWN0b3IiLCJzYXZlTWlzc2luZyIsInNhdmVNaXNzaW5nUGx1cmFscyIsInN1ZmZpeGVzIiwiZ2V0U3VmZml4ZXMiLCJzdWZmaXgiLCJhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkiLCJwYXJzZU1pc3NpbmdLZXlIYW5kbGVyIiwiX3RoaXMiLCJkZWZhdWx0VmFyaWFibGVzIiwic2tpcEludGVycG9sYXRpb24iLCJza2lwT25WYXJpYWJsZXMiLCJuZXN0QmVmIiwibmIiLCJpbnRlcnBvbGF0ZSIsIm5hIiwibmVzdEFmdCIsIm5lc3QiLCJjb250ZXh0IiwicmVzZXQiLCJwb3N0UHJvY2VzcyIsInBvc3RQcm9jZXNzb3JOYW1lcyIsImFwcGx5UG9zdFByb2Nlc3NvciIsInBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkIiwiaTE4blJlc29sdmVkIiwiZm91bmQiLCJleHRyYWN0ZWQiLCJmYWxsYmFja05TIiwibmVlZHNDb250ZXh0SGFuZGxpbmciLCJjb2RlcyIsInV0aWxzIiwiaGFzTG9hZGVkTmFtZXNwYWNlIiwiZmluYWxLZXlzIiwiYWRkTG9va3VwS2V5cyIsInBsdXJhbFN1ZmZpeCIsInplcm9TdWZmaXgiLCJvcmRpbmFsUHJlZml4IiwiY29udGV4dEtleSIsImNvbnRleHRTZXBhcmF0b3IiLCJwb3NzaWJsZUtleSIsInBvcCIsInJldHVybk51bGwiLCJyZXR1cm5FbXB0eVN0cmluZyIsInJlc291cmNlU3RvcmUiLCJvcHRpb25zS2V5cyIsInVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSIsIm9wdGlvbiIsInNlcnZpY2VzIiwiY2FwaXRhbGl6ZSIsInN0cmluZyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiTGFuZ3VhZ2VVdGlsIiwiZ2V0U2NyaXB0UGFydEZyb21Db2RlIiwiZm9ybWF0TGFuZ3VhZ2VDb2RlIiwiZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUiLCJzcGVjaWFsQ2FzZXMiLCJsb3dlckNhc2VMbmciLCJwYXJ0IiwiY2xlYW5Db2RlIiwiaXNTdXBwb3J0ZWRDb2RlIiwibG9hZCIsIm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncyIsInN1cHBvcnRlZExuZ3MiLCJnZXRCZXN0TWF0Y2hGcm9tQ29kZXMiLCJjbGVhbmVkTG5nIiwibG5nT25seSIsInN1cHBvcnRlZExuZyIsImZhbGxiYWNrcyIsImRlZmF1bHQiLCJmYWxsYmFja0NvZGUiLCJmYWxsYmFja0NvZGVzIiwiYWRkQ29kZSIsImZjIiwic2V0cyIsIm5yIiwiX3J1bGVzUGx1cmFsc1R5cGVzIiwiTnVtYmVyIiwibm9uSW50bFZlcnNpb25zIiwiaW50bFZlcnNpb25zIiwic3VmZml4ZXNPcmRlciIsInplcm8iLCJvbmUiLCJ0d28iLCJmZXciLCJtYW55Iiwib3RoZXIiLCJjcmVhdGVSdWxlcyIsInJ1bGVzIiwibnVtYmVycyIsInBsdXJhbHMiLCJQbHVyYWxSZXNvbHZlciIsImFkZFJ1bGUiLCJjbGVhckNhY2hlIiwicGx1cmFsUnVsZXNDYWNoZSIsImdldFJ1bGUiLCJjbGVhbmVkQ29kZSIsImNhY2hlS2V5IiwicnVsZSIsIkludGwiLCJQbHVyYWxSdWxlcyIsImVyciIsIm5lZWRzUGx1cmFsIiwicmVzb2x2ZWRPcHRpb25zIiwicGx1cmFsQ2F0ZWdvcmllcyIsImdldFBsdXJhbEZvcm1zT2ZLZXkiLCJzb3J0IiwicGx1cmFsQ2F0ZWdvcnkxIiwicGx1cmFsQ2F0ZWdvcnkyIiwicGx1cmFsQ2F0ZWdvcnkiLCJwcmVwZW5kIiwibnVtYmVyIiwic2VsZWN0IiwiZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlIiwiaWR4Iiwibm9BYnMiLCJNYXRoIiwiYWJzIiwic2ltcGxpZnlQbHVyYWxTdWZmaXgiLCJyZXR1cm5TdWZmaXgiLCJjb21wYXRpYmlsaXR5SlNPTiIsImluY2x1ZGVzIiwiZGVlcEZpbmRXaXRoRGVmYXVsdHMiLCJyZWdleFNhZmUiLCJ2YWwiLCJJbnRlcnBvbGF0b3IiLCJlc2NhcGVWYWx1ZSIsImVzY2FwZSQxIiwidXNlUmF3VmFsdWVUb0VzY2FwZSIsInByZWZpeEVzY2FwZWQiLCJzdWZmaXhFc2NhcGVkIiwiZm9ybWF0U2VwYXJhdG9yIiwidW5lc2NhcGVTdWZmaXgiLCJ1bmVzY2FwZVByZWZpeCIsIm5lc3RpbmdQcmVmaXgiLCJuZXN0aW5nUHJlZml4RXNjYXBlZCIsIm5lc3RpbmdTdWZmaXgiLCJuZXN0aW5nU3VmZml4RXNjYXBlZCIsIm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIiwibWF4UmVwbGFjZXMiLCJhbHdheXNGb3JtYXQiLCJyZXNldFJlZ0V4cCIsImdldE9yUmVzZXRSZWdFeHAiLCJleGlzdGluZ1JlZ0V4cCIsImxhc3RJbmRleCIsInJlZ2V4cCIsInJlZ2V4cFVuZXNjYXBlIiwicmVwbGFjZXMiLCJoYW5kbGVGb3JtYXQiLCJmb3JtYXQiLCJpbnRlcnBvbGF0aW9ua2V5IiwidHJpbSIsImYiLCJtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIiLCJ0b2RvcyIsInJlZ2V4Iiwic2FmZVZhbHVlIiwidG9kbyIsImV4ZWMiLCJtYXRjaGVkVmFyIiwidGVtcCIsImNsb25lZE9wdGlvbnMiLCJoYW5kbGVIYXNPcHRpb25zIiwiaW5oZXJpdGVkT3B0aW9ucyIsInNlcCIsIm9wdGlvbnNTdHJpbmciLCJtYXRjaGVkU2luZ2xlUXVvdGVzIiwibWF0Y2hlZERvdWJsZVF1b3RlcyIsImZvcm1hdHRlcnMiLCJkb1JlZHVjZSIsImVsZW0iLCJyZWR1Y2UiLCJwYXJzZUZvcm1hdFN0ciIsImZvcm1hdFN0ciIsImZvcm1hdE5hbWUiLCJmb3JtYXRPcHRpb25zIiwib3B0U3RyIiwiY3VycmVuY3kiLCJyYW5nZSIsIm9wdHMiLCJvcHQiLCJyZXN0IiwidHJpbW1lZEtleSIsImlzTmFOIiwicGFyc2VJbnQiLCJjcmVhdGVDYWNoZWRGb3JtYXR0ZXIiLCJmbiIsImNhY2hlIiwib3B0Rm9yQ2FjaGUiLCJmb3JtYXRQYXJhbXMiLCJmb3JtYXR0ZXIiLCJGb3JtYXR0ZXIiLCJpT3B0cyIsImFkZCIsImZvcm1hdHMiLCJhZGRDYWNoZWQiLCJmaW5kSW5kZXgiLCJtZW0iLCJmb3JtYXR0ZWQiLCJ2YWxPcHRpb25zIiwibG9jYWxlIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJkYXRldGltZSIsIkRhdGVUaW1lRm9ybWF0IiwicmVsYXRpdmV0aW1lIiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwibGlzdCIsIkxpc3RGb3JtYXQiLCJyZW1vdmVQZW5kaW5nIiwicSIsInBlbmRpbmciLCJwZW5kaW5nQ291bnQiLCJDb25uZWN0b3IiLCJxdWV1ZUxvYWQiLCJsYW5ndWFnZXMiLCJjYWxsYmFjayIsInRvTG9hZCIsInRvTG9hZExhbmd1YWdlcyIsInRvTG9hZE5hbWVzcGFjZXMiLCJoYXNBbGxOYW1lc3BhY2VzIiwicmVsb2FkIiwic3RvcmUiLCJzdGF0ZSIsInF1ZXVlIiwibG9hZGVkIiwiZXJyb3JzIiwiZG9uZSIsImxvYWRlZEtleXMiLCJyZWFkIiwiZmNOYW1lIiwidHJpZWQiLCJ3YWl0IiwicmV0cnlUaW1lb3V0IiwicmVhZGluZ0NhbGxzIiwibWF4UGFyYWxsZWxSZWFkcyIsIndhaXRpbmdSZWFkcyIsInJlc29sdmVyIiwibWF4UmV0cmllcyIsInNldFRpbWVvdXQiLCJiYWNrZW5kIiwiYmluZCIsInRoZW4iLCJjYXRjaCIsInByZXBhcmVMb2FkaW5nIiwibG9hZE9uZSIsImZhbGxiYWNrVmFsdWUiLCJpc1VwZGF0ZSIsImNsYiIsImluaXRJbW1lZGlhdGUiLCJwcmVsb2FkIiwicGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMiLCJyZXQiLCJ0RGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm1PcHRpb25zIiwibm9vcCIsImJpbmRNZW1iZXJGdW5jdGlvbnMiLCJpbnN0IiwibWVtcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRQcm90b3R5cGVPZiIsIkkxOG4iLCJpc0luaXRpYWxpemluZyIsImRlZk9wdHMiLCJjcmVhdGVDbGFzc09uRGVtYW5kIiwiQ2xhc3NPck9iamVjdCIsImlzQ2xvbmUiLCJtb2R1bGVzIiwibHUiLCJsYW5ndWFnZURldGVjdG9yIiwiZGV0ZWN0aW9uIiwiZXh0ZXJuYWwiLCJzdG9yZUFwaSIsInN0b3JlQXBpQ2hhaW5lZCIsImRlZmVycmVkIiwiZmluaXNoIiwiaXNJbml0aWFsaXplZCIsImluaXRpYWxpemVkU3RvcmVPbmNlIiwibG9hZFJlc291cmNlcyIsInVzZWRDYWxsYmFjayIsImFwcGVuZCIsInJlc29sdmVkTGFuZ3VhZ2UiLCJzZXRSZXNvbHZlZExhbmd1YWdlIiwicmVsb2FkUmVzb3VyY2VzIiwidXNlIiwiRXJyb3IiLCJsaSIsImxuZ0luTG5ncyIsIl90aGlzMiIsImlzTGFuZ3VhZ2VDaGFuZ2luZ1RvIiwic2V0TG5nUHJvcHMiLCJzZXRMbmciLCJjYWNoZVVzZXJMYW5ndWFnZSIsImFzeW5jIiwiZGV0ZWN0IiwiZ2V0Rml4ZWRUIiwia2V5UHJlZml4IiwiX3RoaXMzIiwiZml4ZWRUIiwicmVzdWx0S2V5Iiwic2V0RGVmYXVsdE5hbWVzcGFjZSIsImxhc3RMbmciLCJsb2FkTm90UGVuZGluZyIsImxvYWRTdGF0ZSIsInByZWNoZWNrIiwicHJlUmVzdWx0IiwibG9hZE5hbWVzcGFjZXMiLCJsb2FkTGFuZ3VhZ2VzIiwicHJlbG9hZGVkIiwibmV3TG5ncyIsImRpciIsInJ0bExuZ3MiLCJjcmVhdGVJbnN0YW5jZSIsImNsb25lSW5zdGFuY2UiLCJmb3JrUmVzb3VyY2VTdG9yZSIsIm1lcmdlZE9wdGlvbnMiLCJtZW1iZXJzVG9Db3B5IiwiaW5zdGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/i18next/dist/esm/i18next.js\n"));

/***/ })

});